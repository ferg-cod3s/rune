
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>rune: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ferg-cod3s/rune/cmd/rune/main.go (0.0%)</option>
				
				<option value="file1">github.com/ferg-cod3s/rune/internal/commands/completion.go (16.7%)</option>
				
				<option value="file2">github.com/ferg-cod3s/rune/internal/commands/config.go (7.3%)</option>
				
				<option value="file3">github.com/ferg-cod3s/rune/internal/commands/debug.go (5.4%)</option>
				
				<option value="file4">github.com/ferg-cod3s/rune/internal/commands/init.go (2.9%)</option>
				
				<option value="file5">github.com/ferg-cod3s/rune/internal/commands/pause.go (13.3%)</option>
				
				<option value="file6">github.com/ferg-cod3s/rune/internal/commands/report.go (3.3%)</option>
				
				<option value="file7">github.com/ferg-cod3s/rune/internal/commands/resume.go (13.3%)</option>
				
				<option value="file8">github.com/ferg-cod3s/rune/internal/commands/ritual.go (6.8%)</option>
				
				<option value="file9">github.com/ferg-cod3s/rune/internal/commands/root.go (14.3%)</option>
				
				<option value="file10">github.com/ferg-cod3s/rune/internal/commands/start.go (3.5%)</option>
				
				<option value="file11">github.com/ferg-cod3s/rune/internal/commands/status.go (4.2%)</option>
				
				<option value="file12">github.com/ferg-cod3s/rune/internal/commands/stop.go (6.7%)</option>
				
				<option value="file13">github.com/ferg-cod3s/rune/internal/commands/test.go (4.8%)</option>
				
				<option value="file14">github.com/ferg-cod3s/rune/internal/commands/update.go (9.1%)</option>
				
				<option value="file15">github.com/ferg-cod3s/rune/internal/commands/utils.go (0.0%)</option>
				
				<option value="file16">github.com/ferg-cod3s/rune/internal/config/config.go (51.1%)</option>
				
				<option value="file17">github.com/ferg-cod3s/rune/internal/dnd/dnd.go (10.2%)</option>
				
				<option value="file18">github.com/ferg-cod3s/rune/internal/notifications/notifications.go (68.3%)</option>
				
				<option value="file19">github.com/ferg-cod3s/rune/internal/rituals/engine.go (0.0%)</option>
				
				<option value="file20">github.com/ferg-cod3s/rune/internal/telemetry/middleware.go (32.6%)</option>
				
				<option value="file21">github.com/ferg-cod3s/rune/internal/telemetry/telemetry.go (49.4%)</option>
				
				<option value="file22">github.com/ferg-cod3s/rune/internal/tracking/idle.go (13.2%)</option>
				
				<option value="file23">github.com/ferg-cod3s/rune/internal/tracking/project.go (65.8%)</option>
				
				<option value="file24">github.com/ferg-cod3s/rune/internal/tracking/session.go (80.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/ferg-cod3s/rune/internal/commands"
)

func main() <span class="cov0" title="0">{
        if err := commands.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package commands

import (
        "os"

        "github.com/spf13/cobra"
)

// completionCmd represents the completion command
var completionCmd = &amp;cobra.Command{
        Use:   "completion [bash|zsh|fish|powershell]",
        Short: "Generate completion script",
        Long: `To load completions:

Bash:

  $ source &lt;(rune completion bash)

  # To load completions for each session, execute once:
  # Linux:
  $ rune completion bash &gt; /etc/bash_completion.d/rune
  # macOS:
  $ rune completion bash &gt; /usr/local/etc/bash_completion.d/rune

Zsh:

  # If shell completion is not already enabled in your environment,
  # you will need to enable it.  You can execute the following once:

  $ echo "autoload -U compinit; compinit" &gt;&gt; ~/.zshrc

  # To load completions for each session, execute once:
  $ rune completion zsh &gt; "${fpath[1]}/_rune"

  # You will need to start a new shell for this setup to take effect.

fish:

  $ rune completion fish | source

  # To load completions for each session, execute once:
  $ rune completion fish &gt; ~/.config/fish/completions/rune.fish

PowerShell:

  PS&gt; rune completion powershell | Out-String | Invoke-Expression

  # To load completions for every new session, run:
  PS&gt; rune completion powershell &gt; rune.ps1
  # and source this file from your PowerShell profile.
`,
        DisableFlagsInUseLine: true,
        ValidArgs:             []string{"bash", "zsh", "fish", "powershell"},
        Args:                  cobra.MatchAll(cobra.ExactArgs(1), cobra.OnlyValidArgs),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                switch args[0] </span>{
                case "bash":<span class="cov0" title="0">
                        _ = cmd.Root().GenBashCompletion(os.Stdout)</span>
                case "zsh":<span class="cov0" title="0">
                        _ = cmd.Root().GenZshCompletion(os.Stdout)</span>
                case "fish":<span class="cov0" title="0">
                        _ = cmd.Root().GenFishCompletion(os.Stdout, true)</span>
                case "powershell":<span class="cov0" title="0">
                        _ = cmd.Root().GenPowerShellCompletionWithDesc(os.Stdout)</span>
                }
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(completionCmd)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package commands

import (
        "fmt"
        "os"
        "os/exec"

        "github.com/ferg-cod3s/rune/internal/config"
        "github.com/spf13/cobra"
)

var configCmd = &amp;cobra.Command{
        Use:   "config",
        Short: "Manage Rune configuration",
        Long: `Manage your Rune configuration file.

This command provides subcommands to edit, validate, and manage
your Rune configuration.`,
}

var configEditCmd = &amp;cobra.Command{
        Use:   "edit",
        Short: "Edit the configuration file",
        Long:  `Open the configuration file in your default editor.`,
        RunE:  runConfigEdit,
}

var configValidateCmd = &amp;cobra.Command{
        Use:   "validate",
        Short: "Validate the configuration file",
        Long:  `Validate the syntax and content of your configuration file.`,
        RunE:  runConfigValidate,
}

var configShowCmd = &amp;cobra.Command{
        Use:   "show",
        Short: "Show the current configuration",
        Long:  `Display the current configuration with resolved values.`,
        RunE:  runConfigShow,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(configCmd)
        configCmd.AddCommand(configEditCmd)
        configCmd.AddCommand(configValidateCmd)
        configCmd.AddCommand(configShowCmd)
}</span>

func runConfigEdit(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        configPath, err := config.GetConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">exists, err := config.Exists()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                fmt.Println("⚠ Configuration file does not exist.")
                fmt.Println("Run 'rune init' to create a new configuration.")
                return nil
        }</span>

        <span class="cov0" title="0">editor := os.Getenv("EDITOR")
        if editor == "" </span><span class="cov0" title="0">{
                editor = "vi" // fallback to vi
        }</span>

        <span class="cov0" title="0">cmd_exec := exec.Command(editor, configPath)
        cmd_exec.Stdin = os.Stdin
        cmd_exec.Stdout = os.Stdout
        cmd_exec.Stderr = os.Stderr

        return cmd_exec.Run()</span>
}

func runConfigValidate(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        exists, err := config.Exists()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                fmt.Println("⚠ Configuration file does not exist.")
                fmt.Println("Run 'rune init' to create a new configuration.")
                return nil
        }</span>

        <span class="cov0" title="0">cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Configuration validation failed: %v\n", err)
                return nil // Don't return error to avoid double error message
        }</span>

        <span class="cov0" title="0">fmt.Println("✅ Configuration is valid!")
        fmt.Printf("   Version: %d\n", cfg.Version)
        fmt.Printf("   Projects: %d\n", len(cfg.Projects))
        fmt.Printf("   Work hours: %.1f\n", cfg.Settings.WorkHours)

        return nil</span>
}

func runConfigShow(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        exists, err := config.Exists()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                fmt.Println("⚠ Configuration file does not exist.")
                fmt.Println("Run 'rune init' to create a new configuration.")
                return nil
        }</span>

        <span class="cov0" title="0">configPath, err := config.GetConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">content, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Configuration file: %s\n", configPath)
        fmt.Println("=" + string(make([]byte, len(configPath)+20)))
        fmt.Print(string(content))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package commands

import (
        "fmt"
        "net/http"
        "os"
        "runtime"
        "strings"
        "time"

        "github.com/ferg-cod3s/rune/internal/config"
        "github.com/ferg-cod3s/rune/internal/telemetry"
        "github.com/spf13/cobra"
)

var debugCmd = &amp;cobra.Command{
        Use:   "debug",
        Short: "Debug and diagnostic commands",
        Long:  "Debug and diagnostic commands for troubleshooting Rune issues",
}

var debugTelemetryCmd = &amp;cobra.Command{
        Use:   "telemetry",
        Short: "Debug telemetry configuration and connectivity",
        Long:  "Show telemetry configuration, test connectivity, and verify event delivery",
        RunE:  runDebugTelemetry,
}

var debugKeysCmd = &amp;cobra.Command{
        Use:   "keys",
        Short: "Show telemetry key configuration (masked for security)",
        Long:  "Display telemetry API keys and DSNs with masking for security",
        RunE:  runDebugKeys,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(debugCmd)
        debugCmd.AddCommand(debugTelemetryCmd)
        debugCmd.AddCommand(debugKeysCmd)

        // Wrap debug commands with telemetry
        telemetry.WrapCommand(debugTelemetryCmd, runDebugTelemetry)
        telemetry.WrapCommand(debugKeysCmd, runDebugKeys)
}</span>

func runDebugTelemetry(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        fmt.Println("🔍 Rune Telemetry Debug Report")
        fmt.Println("=" + strings.Repeat("=", 40))

        // System Information
        fmt.Printf("\n📊 System Information:\n")
        fmt.Printf("  OS: %s\n", runtime.GOOS)
        fmt.Printf("  Architecture: %s\n", runtime.GOARCH)
        fmt.Printf("  Go Version: %s\n", runtime.Version())

        // Environment Variables
        fmt.Printf("\n🌍 Environment Variables:\n")
        fmt.Printf("  RUNE_TELEMETRY_DISABLED: %s\n", getEnvOrDefault("RUNE_TELEMETRY_DISABLED", "not set"))
        fmt.Printf("  RUNE_DEBUG: %s\n", getEnvOrDefault("RUNE_DEBUG", "not set"))
        fmt.Printf("  RUNE_ENV: %s\n", getEnvOrDefault("RUNE_ENV", "not set"))
        fmt.Printf("  RUNE_SEGMENT_WRITE_KEY: %s\n", maskKey(os.Getenv("RUNE_SEGMENT_WRITE_KEY")))
        fmt.Printf("  RUNE_SENTRY_DSN: %s\n", maskDSN(os.Getenv("RUNE_SENTRY_DSN")))

        // Configuration File
        fmt.Printf("\n📄 Configuration:\n")
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("  Config Load Error: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  Config File Found: ✅\n")
                fmt.Printf("  Telemetry Enabled: %t\n", cfg.Integrations.Telemetry.Enabled)
                fmt.Printf("  Segment Key (config): %s\n", maskKey(cfg.Integrations.Telemetry.SegmentWriteKey))
                fmt.Printf("  Sentry DSN (config): %s\n", maskDSN(cfg.Integrations.Telemetry.SentryDSN))
                fmt.Printf("  User ID: %s\n", cfg.UserID)
        }</span>

        // Build-time Keys (check if embedded)
        <span class="cov0" title="0">fmt.Printf("\n🔧 Build-time Configuration:\n")
        fmt.Printf("  Build-time keys embedded: %s\n", checkBuildTimeKeys())

        // Network Connectivity Tests
        fmt.Printf("\n🌐 Network Connectivity:\n")
        testConnectivity("Segment API", "https://api.segment.io/v1/track")
        testConnectivity("Sentry API", "https://sentry.io/api/")

        // Test Event Sending
        fmt.Printf("\n📡 Test Event Sending:\n")
        testEventSending()

        return nil</span>
}

func runDebugKeys(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        fmt.Println("🔑 Rune API Keys Debug")
        fmt.Println("=" + strings.Repeat("=", 30))

        // Environment Variables
        segmentEnv := os.Getenv("RUNE_SEGMENT_WRITE_KEY")
        sentryEnv := os.Getenv("RUNE_SENTRY_DSN")

        fmt.Printf("\n🌍 Environment Variables:\n")
        fmt.Printf("  RUNE_SEGMENT_WRITE_KEY: %s\n", maskKey(segmentEnv))
        fmt.Printf("  RUNE_SENTRY_DSN: %s\n", maskDSN(sentryEnv))

        // Configuration File
        cfg, err := config.Load()
        if err == nil </span><span class="cov0" title="0">{
                fmt.Printf("\n📄 Configuration File:\n")
                fmt.Printf("  Segment Key: %s\n", maskKey(cfg.Integrations.Telemetry.SegmentWriteKey))
                fmt.Printf("  Sentry DSN: %s\n", maskDSN(cfg.Integrations.Telemetry.SentryDSN))
        }</span>

        // Final Resolution
        <span class="cov0" title="0">finalSegment := segmentEnv
        if finalSegment == "" &amp;&amp; cfg != nil </span><span class="cov0" title="0">{
                finalSegment = cfg.Integrations.Telemetry.SegmentWriteKey
        }</span>

        <span class="cov0" title="0">finalSentry := sentryEnv
        if finalSentry == "" &amp;&amp; cfg != nil </span><span class="cov0" title="0">{
                finalSentry = cfg.Integrations.Telemetry.SentryDSN
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n✅ Final Resolution:\n")
        fmt.Printf("  Active Segment Key: %s\n", maskKey(finalSegment))
        fmt.Printf("  Active Sentry DSN: %s\n", maskDSN(finalSentry))

        // Validation
        fmt.Printf("\n🔍 Validation:\n")
        if finalSegment == "" </span><span class="cov0" title="0">{
                fmt.Printf("  ❌ No Segment key configured\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  ✅ Segment key configured (%d chars)\n", len(finalSegment))
        }</span>

        <span class="cov0" title="0">if finalSentry == "" </span><span class="cov0" title="0">{
                fmt.Printf("  ❌ No Sentry DSN configured\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  ✅ Sentry DSN configured (%d chars)\n", len(finalSentry))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func getEnvOrDefault(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func maskKey(key string) string <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return "not set"
        }</span>
        <span class="cov0" title="0">if len(key) &lt;= 8 </span><span class="cov0" title="0">{
                return strings.Repeat("*", len(key))
        }</span>
        <span class="cov0" title="0">return key[:4] + strings.Repeat("*", len(key)-8) + key[len(key)-4:]</span>
}

func maskDSN(dsn string) string <span class="cov0" title="0">{
        if dsn == "" </span><span class="cov0" title="0">{
                return "not set"
        }</span>
        // For Sentry DSN format: https://public_key@sentry.io/project_id
        <span class="cov0" title="0">if strings.Contains(dsn, "@") </span><span class="cov0" title="0">{
                parts := strings.Split(dsn, "@")
                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        return maskKey(parts[0]) + "@" + parts[1]
                }</span>
        }
        <span class="cov0" title="0">return maskKey(dsn)</span>
}

func checkBuildTimeKeys() string <span class="cov0" title="0">{
        // This is a simple check - in a real implementation, you'd check if build-time
        // variables were properly injected during the build process
        // For now, we'll indicate if the binary likely has embedded keys
        return "checking..." // This would need actual implementation
}</span>

func testConnectivity(name, url string) <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: 5 * time.Second}
        resp, err := client.Head(url)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("  %s: ❌ Failed (%v)\n", name, err)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 400 </span><span class="cov0" title="0">{
                fmt.Printf("  %s: ✅ Connected (HTTP %d)\n", name, resp.StatusCode)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  %s: ⚠️  HTTP %d\n", name, resp.StatusCode)
        }</span>
}

func testEventSending() <span class="cov0" title="0">{
        fmt.Printf("  Sending test event...\n")

        // Send a test event
        telemetry.Track("debug_test_event", map[string]interface{}{
                "test":      true,
                "timestamp": time.Now().Unix(),
                "source":    "debug_command",
        })

        fmt.Printf("  ✅ Test event sent (check your analytics dashboard)\n")
        fmt.Printf("  💡 Enable RUNE_DEBUG=true for detailed telemetry logs\n")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package commands

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/ferg-cod3s/rune/internal/config"
        "github.com/spf13/cobra"
)

var initCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize Rune configuration",
        Long: `Initialize your Rune configuration with guided setup.

This command will create a configuration file at ~/.rune/config.yaml
and walk you through setting up your first rituals and work preferences.`,
        RunE: runInit,
}

var (
        guided bool
)

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(initCmd)
        initCmd.Flags().BoolVar(&amp;guided, "guided", false, "Use interactive guided setup")
}</span>

func runInit(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        configPath, err := config.GetConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create .rune directory if it doesn't exist
        <span class="cov0" title="0">runeDir := filepath.Dir(configPath)
        if err := os.MkdirAll(runeDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create .rune directory: %w", err)
        }</span>

        // Check if config already exists
        <span class="cov0" title="0">exists, err := config.Exists()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                fmt.Printf("⚠ Configuration already exists at %s\n", configPath)
                fmt.Println("Use 'rune config edit' to modify your existing configuration.")
                return nil
        }</span>

        <span class="cov0" title="0">if guided </span><span class="cov0" title="0">{
                return runGuidedInit(configPath)
        }</span>

        <span class="cov0" title="0">return createDefaultConfig(configPath)</span>
}

func runGuidedInit(configPath string) error <span class="cov0" title="0">{
        // Special ceremonial runic logo for initialization
        fmt.Println("|~\\  |\\      |   |\\    /|")
        fmt.Println("|  \\ | \\   \\ |   | \\  / |")
        fmt.Println("|  / |  \\   \\|   |  \\/  |")
        fmt.Println("|_/  |   |   |\\  |      |")
        fmt.Println("| \\  |   |   | \\ |      |")
        fmt.Println("|  \\ |   |   |   |      |")
        fmt.Println()
        fmt.Println("🔮 Ancient runes awaken... Welcome to Rune!")
        fmt.Println("Let's cast your daily rituals and bind your workflow.")
        fmt.Println()

        // Ask for telemetry opt-in
        telemetryEnabled := promptTelemetryOptIn()

        if err := createDefaultConfigWithTelemetry(configPath, telemetryEnabled); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("✓ Configuration created at %s\n", configPath)
        if telemetryEnabled </span><span class="cov0" title="0">{
                fmt.Println("✓ Telemetry enabled - helping improve Rune")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("✓ Telemetry disabled - fully private usage")
        }</span>
        <span class="cov0" title="0">fmt.Println("✓ Ready to begin your ritual automation")
        fmt.Println()
        fmt.Println("Try 'rune start' to begin your workday!")

        return nil</span>
}

func createDefaultConfig(configPath string) error <span class="cov0" title="0">{
        return createDefaultConfigWithTelemetry(configPath, false)
}</span>

func createDefaultConfigWithTelemetry(configPath string, telemetryEnabled bool) error <span class="cov0" title="0">{
        telemetryConfig := "false"
        if telemetryEnabled </span><span class="cov0" title="0">{
                telemetryConfig = "true"
        }</span>

        <span class="cov0" title="0">defaultConfig := fmt.Sprintf(`version: 1
settings:
  work_hours: 8.0
  break_interval: 50m
  idle_threshold: 10m

projects:
  - name: "default"
    detect: ["git:.*", "dir:~/"]

rituals:
  start:
    global:
      - name: "Welcome ritual"
        command: "echo 'Starting your workday...'"
  stop:
    global:
      - name: "Farewell ritual"
        command: "echo 'Ending your workday...'"

integrations:
  git:
    enabled: true
    auto_detect_project: true
  telemetry:
    enabled: %s
`, telemetryConfig)

        if err := os.WriteFile(configPath, []byte(defaultConfig), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func promptTelemetryOptIn() bool <span class="cov0" title="0">{
        fmt.Println("📊 Help improve Rune")
        fmt.Println()
        fmt.Println("Rune can collect anonymous usage data and error reports to help")
        fmt.Println("improve the tool. This includes:")
        fmt.Println("  • Command usage patterns (no personal data)")
        fmt.Println("  • Error reports and crash logs")
        fmt.Println("  • Performance metrics")
        fmt.Println()
        fmt.Println("All data is anonymous and helps make Rune better for everyone.")
        fmt.Println("You can change this setting anytime with 'rune config edit'")
        fmt.Println()

        reader := bufio.NewReader(os.Stdin)
        for </span><span class="cov0" title="0">{
                fmt.Print("Enable telemetry? [y/N]: ")
                response, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">response = strings.TrimSpace(strings.ToLower(response))
                switch response </span>{
                case "y", "yes":<span class="cov0" title="0">
                        return true</span>
                case "n", "no", "":<span class="cov0" title="0">
                        return false</span>
                default:<span class="cov0" title="0">
                        fmt.Println("Please answer 'y' for yes or 'n' for no.")</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package commands

import (
        "fmt"

        "github.com/ferg-cod3s/rune/internal/telemetry"
        "github.com/ferg-cod3s/rune/internal/tracking"
        "github.com/spf13/cobra"
)

var pauseCmd = &amp;cobra.Command{
        Use:   "pause",
        Short: "Pause the current work timer",
        Long: `Pause the current work session timer.

This command will:
- Pause the active work timer
- Optionally disable focus mode
- Save the current session state`,
        RunE: runPause,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(pauseCmd)

        // Wrap command with telemetry
        telemetry.WrapCommand(pauseCmd, runPause)
}</span>

func runPause(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        fmt.Println("⏸ Pausing work timer...")

        // Initialize tracker
        tracker, err := tracking.NewTracker()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize tracker: %w", err)
        }</span>
        <span class="cov0" title="0">defer tracker.Close()

        // Pause the session
        session, err := tracker.Pause()
        if err != nil </span><span class="cov0" title="0">{
                telemetry.TrackError(err, "pause", map[string]interface{}{
                        "step": "tracker_pause",
                })
                return fmt.Errorf("failed to pause session: %w", err)
        }</span>

        // Track successful pause
        <span class="cov0" title="0">telemetry.Track("session_paused", map[string]interface{}{
                "project": session.Project,
        })

        fmt.Println("✓ Timer paused")
        fmt.Println("💡 Use 'rune resume' to continue your session")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package commands

import (
        "encoding/csv"
        "encoding/json"
        "fmt"
        "os"
        "strconv"
        "time"

        "github.com/ferg-cod3s/rune/internal/tracking"
        "github.com/spf13/cobra"
)

var reportCmd = &amp;cobra.Command{
        Use:   "report",
        Short: "Generate time reports",
        Long: `Generate time tracking reports for different periods.

This command can show:
- Daily work summaries
- Weekly productivity reports
- Project-based time allocation
- Monthly trends and insights`,
        RunE: runReport,
}

var (
        today   bool
        week    bool
        month   bool
        project string
        format  string
        output  string
)

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(reportCmd)

        reportCmd.Flags().BoolVar(&amp;today, "today", false, "Show today's report")
        reportCmd.Flags().BoolVar(&amp;week, "week", false, "Show this week's report")
        reportCmd.Flags().BoolVar(&amp;month, "month", false, "Show this month's report")
        reportCmd.Flags().StringVar(&amp;project, "project", "", "Filter by project name")
        reportCmd.Flags().StringVar(&amp;format, "format", "text", "Output format: text, csv, json")
        reportCmd.Flags().StringVar(&amp;output, "output", "", "Output file (default: stdout)")
}</span>

func runReport(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        var sessions []*tracking.Session
        var totalDuration time.Duration
        var err error

        // Initialize tracker
        tracker, err := tracking.NewTracker()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize tracker: %w", err)
        }</span>
        <span class="cov0" title="0">defer tracker.Close()

        // Get data based on period
        if today </span><span class="cov0" title="0">{
                sessions, totalDuration, err = getTodayData(tracker)
        }</span> else<span class="cov0" title="0"> if week </span><span class="cov0" title="0">{
                sessions, totalDuration, err = getWeekData(tracker)
        }</span> else<span class="cov0" title="0"> if month </span><span class="cov0" title="0">{
                sessions, totalDuration, err = getMonthData(tracker)
        }</span> else<span class="cov0" title="0"> {
                // Default to today's report
                sessions, totalDuration, err = getTodayData(tracker)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Filter by project if specified
        <span class="cov0" title="0">if project != "" </span><span class="cov0" title="0">{
                var filteredSessions []*tracking.Session
                var filteredDuration time.Duration
                for _, session := range sessions </span><span class="cov0" title="0">{
                        if session.Project == project </span><span class="cov0" title="0">{
                                filteredSessions = append(filteredSessions, session)
                                filteredDuration += session.Duration
                        }</span>
                }
                <span class="cov0" title="0">sessions = filteredSessions
                totalDuration = filteredDuration</span>
        }

        // Output based on format
        <span class="cov0" title="0">switch format </span>{
        case "csv":<span class="cov0" title="0">
                return exportCSV(sessions, totalDuration)</span>
        case "json":<span class="cov0" title="0">
                return exportJSON(sessions, totalDuration)</span>
        default:<span class="cov0" title="0">
                // Show text report
                if today </span><span class="cov0" title="0">{
                        return showTodayReport()
                }</span> else<span class="cov0" title="0"> if week </span><span class="cov0" title="0">{
                        return showWeekReport()
                }</span> else<span class="cov0" title="0"> if month </span><span class="cov0" title="0">{
                        return showMonthReport()
                }</span> else<span class="cov0" title="0"> {
                        return showTodayReport()
                }</span>
        }
}

func showTodayReport() error <span class="cov0" title="0">{
        fmt.Println("📈 Today's Report")
        fmt.Println("=================")
        fmt.Println()

        // Initialize tracker
        tracker, err := tracking.NewTracker()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize tracker: %w", err)
        }</span>
        <span class="cov0" title="0">defer tracker.Close()

        // Get daily total
        dailyTotal, err := tracker.GetDailyTotal()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get daily total: %w", err)
        }</span>

        // Get project stats for today
        <span class="cov0" title="0">projectStats, err := tracker.GetProjectStats()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project stats: %w", err)
        }</span>

        // Get today's sessions
        <span class="cov0" title="0">sessions, err := tracker.GetSessionHistory(50) // Get more to filter by today
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get session history: %w", err)
        }</span>

        // Filter sessions for today
        <span class="cov0" title="0">today := time.Now().Truncate(24 * time.Hour)
        tomorrow := today.Add(24 * time.Hour)
        var todaySessions []*tracking.Session
        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.StartTime.After(today) &amp;&amp; session.StartTime.Before(tomorrow) </span><span class="cov0" title="0">{
                        if project == "" || session.Project == project </span><span class="cov0" title="0">{
                                todaySessions = append(todaySessions, session)
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("Total Time:    %s\n", formatDuration(dailyTotal))
        fmt.Printf("Sessions:      %d\n", len(todaySessions))

        if len(projectStats) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\nProject Breakdown:")
                for proj, duration := range projectStats </span><span class="cov0" title="0">{
                        if project == "" || proj == project </span><span class="cov0" title="0">{
                                fmt.Printf("  %-15s %s\n", proj, formatDuration(duration))
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(todaySessions) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\nToday's Sessions:")
                for _, session := range todaySessions </span><span class="cov0" title="0">{
                        fmt.Printf("  %s  %-15s  %s\n",
                                session.StartTime.Format("15:04"),
                                session.Project,
                                formatDuration(session.Duration))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func showWeekReport() error <span class="cov0" title="0">{
        fmt.Println("📈 This Week's Report")
        fmt.Println("=====================")
        fmt.Println()

        // Initialize tracker
        tracker, err := tracking.NewTracker()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize tracker: %w", err)
        }</span>
        <span class="cov0" title="0">defer tracker.Close()

        // Get weekly total
        weeklyTotal, err := tracker.GetWeeklyTotal()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get weekly total: %w", err)
        }</span>

        // Calculate daily average (divide by 7 days)
        <span class="cov0" title="0">dailyAverage := weeklyTotal / 7

        // Get project stats
        projectStats, err := tracker.GetProjectStats()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project stats: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Total Time:    %s\n", formatDuration(weeklyTotal))
        fmt.Printf("Daily Average: %s\n", formatDuration(dailyAverage))

        if len(projectStats) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\nProject Breakdown:")
                for proj, duration := range projectStats </span><span class="cov0" title="0">{
                        if project == "" || proj == project </span><span class="cov0" title="0">{
                                fmt.Printf("  %-15s %s\n", proj, formatDuration(duration))
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func showMonthReport() error <span class="cov0" title="0">{
        fmt.Println("📈 This Month's Report")
        fmt.Println("======================")
        fmt.Println()

        // Initialize tracker
        tracker, err := tracking.NewTracker()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize tracker: %w", err)
        }</span>
        <span class="cov0" title="0">defer tracker.Close()

        // Get monthly total (approximate - get all sessions and filter)
        sessions, err := tracker.GetSessionHistory(1000) // Get many sessions
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get session history: %w", err)
        }</span>

        // Filter for this month
        <span class="cov0" title="0">now := time.Now()
        monthStart := time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location())
        monthEnd := monthStart.AddDate(0, 1, 0)

        var monthlyTotal time.Duration
        var monthlySessions []*tracking.Session
        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.StartTime.After(monthStart) &amp;&amp; session.StartTime.Before(monthEnd) </span><span class="cov0" title="0">{
                        if project == "" || session.Project == project </span><span class="cov0" title="0">{
                                monthlyTotal += session.Duration
                                monthlySessions = append(monthlySessions, session)
                        }</span>
                }
        }

        // Calculate daily average
        <span class="cov0" title="0">daysInMonth := monthEnd.Sub(monthStart).Hours() / 24
        dailyAverage := time.Duration(float64(monthlyTotal) / daysInMonth)

        // Get project stats
        projectStats, err := tracker.GetProjectStats()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get project stats: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Total Time:    %s\n", formatDuration(monthlyTotal))
        fmt.Printf("Daily Average: %s\n", formatDuration(dailyAverage))
        fmt.Printf("Sessions:      %d\n", len(monthlySessions))

        if len(projectStats) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\nProject Breakdown:")
                for proj, duration := range projectStats </span><span class="cov0" title="0">{
                        if project == "" || proj == project </span><span class="cov0" title="0">{
                                fmt.Printf("  %-15s %s\n", proj, formatDuration(duration))
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// getTodayData returns today's sessions and total duration
func getTodayData(tracker *tracking.Tracker) ([]*tracking.Session, time.Duration, error) <span class="cov0" title="0">{
        sessions, err := tracker.GetSessionHistory(50)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">today := time.Now().Truncate(24 * time.Hour)
        tomorrow := today.Add(24 * time.Hour)
        var todaySessions []*tracking.Session
        var totalDuration time.Duration

        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.StartTime.After(today) &amp;&amp; session.StartTime.Before(tomorrow) </span><span class="cov0" title="0">{
                        todaySessions = append(todaySessions, session)
                        totalDuration += session.Duration
                }</span>
        }

        <span class="cov0" title="0">return todaySessions, totalDuration, nil</span>
}

// getWeekData returns this week's sessions and total duration
func getWeekData(tracker *tracking.Tracker) ([]*tracking.Session, time.Duration, error) <span class="cov0" title="0">{
        sessions, err := tracker.GetSessionHistory(500)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">now := time.Now()
        weekStart := now.AddDate(0, 0, -int(now.Weekday()))
        weekStart = weekStart.Truncate(24 * time.Hour)
        weekEnd := weekStart.Add(7 * 24 * time.Hour)
        var weekSessions []*tracking.Session
        var totalDuration time.Duration

        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.StartTime.After(weekStart) &amp;&amp; session.StartTime.Before(weekEnd) </span><span class="cov0" title="0">{
                        weekSessions = append(weekSessions, session)
                        totalDuration += session.Duration
                }</span>
        }

        <span class="cov0" title="0">return weekSessions, totalDuration, nil</span>
}

// getMonthData returns this month's sessions and total duration
func getMonthData(tracker *tracking.Tracker) ([]*tracking.Session, time.Duration, error) <span class="cov0" title="0">{
        sessions, err := tracker.GetSessionHistory(1000)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">now := time.Now()
        monthStart := time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location())
        monthEnd := monthStart.AddDate(0, 1, 0)
        var monthSessions []*tracking.Session
        var totalDuration time.Duration

        for _, session := range sessions </span><span class="cov0" title="0">{
                if session.StartTime.After(monthStart) &amp;&amp; session.StartTime.Before(monthEnd) </span><span class="cov0" title="0">{
                        monthSessions = append(monthSessions, session)
                        totalDuration += session.Duration
                }</span>
        }

        <span class="cov0" title="0">return monthSessions, totalDuration, nil</span>
}

// exportCSV exports sessions to CSV format
func exportCSV(sessions []*tracking.Session, totalDuration time.Duration) error <span class="cov0" title="0">{
        var writer *csv.Writer
        if output != "" </span><span class="cov0" title="0">{
                file, err := os.Create(output)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create output file: %w", err)
                }</span>
                <span class="cov0" title="0">defer file.Close()
                writer = csv.NewWriter(file)</span>
        } else<span class="cov0" title="0"> {
                writer = csv.NewWriter(os.Stdout)
        }</span>
        <span class="cov0" title="0">defer writer.Flush()

        // Write header
        if err := writer.Write([]string{"Date", "Start Time", "End Time", "Project", "Duration (minutes)", "State"}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write CSV header: %w", err)
        }</span>

        // Write sessions
        <span class="cov0" title="0">for _, session := range sessions </span><span class="cov0" title="0">{
                endTime := ""
                if session.EndTime != nil </span><span class="cov0" title="0">{
                        endTime = session.EndTime.Format("15:04:05")
                }</span>

                <span class="cov0" title="0">durationMinutes := strconv.FormatFloat(session.Duration.Minutes(), 'f', 2, 64)

                record := []string{
                        session.StartTime.Format("2006-01-02"),
                        session.StartTime.Format("15:04:05"),
                        endTime,
                        session.Project,
                        durationMinutes,
                        session.State.String(),
                }

                if err := writer.Write(record); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write CSV record: %w", err)
                }</span>
        }

        // Write summary row
        <span class="cov0" title="0">totalMinutes := strconv.FormatFloat(totalDuration.Minutes(), 'f', 2, 64)
        summaryRecord := []string{"TOTAL", "", "", "", totalMinutes, ""}
        if err := writer.Write(summaryRecord); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write CSV summary: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReportData represents the structure for JSON export
type ReportData struct {
        GeneratedAt   time.Time              `json:"generated_at"`
        TotalDuration string                 `json:"total_duration"`
        Sessions      []*tracking.Session    `json:"sessions"`
        Summary       map[string]interface{} `json:"summary"`
}

// exportJSON exports sessions to JSON format
func exportJSON(sessions []*tracking.Session, totalDuration time.Duration) error <span class="cov0" title="0">{
        // Calculate project breakdown
        projectStats := make(map[string]time.Duration)
        for _, session := range sessions </span><span class="cov0" title="0">{
                projectStats[session.Project] += session.Duration
        }</span>

        // Convert project stats to string format for JSON
        <span class="cov0" title="0">projectStatsStr := make(map[string]string)
        for project, duration := range projectStats </span><span class="cov0" title="0">{
                projectStatsStr[project] = formatDuration(duration)
        }</span>

        <span class="cov0" title="0">data := ReportData{
                GeneratedAt:   time.Now(),
                TotalDuration: formatDuration(totalDuration),
                Sessions:      sessions,
                Summary: map[string]interface{}{
                        "total_sessions":    len(sessions),
                        "project_breakdown": projectStatsStr,
                },
        }

        var jsonData []byte
        var err error
        jsonData, err = json.MarshalIndent(data, "", "  ")

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal JSON: %w", err)
        }</span>

        <span class="cov0" title="0">if output != "" </span><span class="cov0" title="0">{
                if err := os.WriteFile(output, jsonData, 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write output file: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Println(string(jsonData))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package commands

import (
        "fmt"

        "github.com/ferg-cod3s/rune/internal/telemetry"
        "github.com/ferg-cod3s/rune/internal/tracking"
        "github.com/spf13/cobra"
)

var resumeCmd = &amp;cobra.Command{
        Use:   "resume",
        Short: "Resume the paused work timer",
        Long: `Resume a previously paused work session timer.

This command will:
- Resume the paused work timer
- Optionally re-enable focus mode
- Continue tracking the current session`,
        RunE: runResume,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(resumeCmd)

        // Wrap command with telemetry
        telemetry.WrapCommand(resumeCmd, runResume)
}</span>

func runResume(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        fmt.Println("▶️ Resuming work timer...")

        // Initialize tracker
        tracker, err := tracking.NewTracker()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize tracker: %w", err)
        }</span>
        <span class="cov0" title="0">defer tracker.Close()

        // Resume the session
        session, err := tracker.Resume()
        if err != nil </span><span class="cov0" title="0">{
                telemetry.TrackError(err, "resume", map[string]interface{}{
                        "step": "tracker_resume",
                })
                return fmt.Errorf("failed to resume session: %w", err)
        }</span>

        // Track successful resume
        <span class="cov0" title="0">telemetry.Track("session_resumed", map[string]interface{}{
                "project": session.Project,
        })

        fmt.Println("✓ Timer resumed")
        fmt.Println("🎯 Back to work!")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package commands

import (
        "fmt"

        "github.com/ferg-cod3s/rune/internal/config"
        "github.com/ferg-cod3s/rune/internal/rituals"
        "github.com/ferg-cod3s/rune/internal/tracking"
        "github.com/spf13/cobra"
)

var ritualCmd = &amp;cobra.Command{
        Use:   "ritual",
        Short: "Manage and test rituals",
        Long: `Manage and test your configured rituals.
        
This command provides subcommands to list, run, and test rituals
without affecting your time tracking.`,
}

var ritualListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List available rituals",
        Long:  `List all configured rituals for all projects.`,
        RunE:  runRitualList,
}

var ritualTestCmd = &amp;cobra.Command{
        Use:   "test &lt;start|stop&gt; [project]",
        Short: "Test a ritual without executing it",
        Long:  `Test a ritual configuration without actually executing the commands.`,
        Args:  cobra.RangeArgs(1, 2),
        RunE:  runRitualTest,
}

var ritualRunCmd = &amp;cobra.Command{
        Use:   "run &lt;start|stop&gt; [project]",
        Short: "Run a specific ritual",
        Long:  `Run a specific ritual without affecting time tracking.`,
        Args:  cobra.RangeArgs(1, 2),
        RunE:  runRitualRun,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(ritualCmd)
        ritualCmd.AddCommand(ritualListCmd)
        ritualCmd.AddCommand(ritualTestCmd)
        ritualCmd.AddCommand(ritualRunCmd)
}</span>

func runRitualList(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("🔮 Configured Rituals")
        fmt.Println("====================")
        fmt.Println()

        // Show start rituals
        fmt.Println("Start Rituals:")
        if len(cfg.Rituals.Start.Global) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("  Global:")
                for _, cmd := range cfg.Rituals.Start.Global </span><span class="cov0" title="0">{
                        fmt.Printf("    - %s: %s\n", cmd.Name, cmd.Command)
                }</span>
        }

        <span class="cov0" title="0">if len(cfg.Rituals.Start.PerProject) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("  Per-Project:")
                for project, commands := range cfg.Rituals.Start.PerProject </span><span class="cov0" title="0">{
                        fmt.Printf("    %s:\n", project)
                        for _, cmd := range commands </span><span class="cov0" title="0">{
                                fmt.Printf("      - %s: %s\n", cmd.Name, cmd.Command)
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Println()

        // Show stop rituals
        fmt.Println("Stop Rituals:")
        if len(cfg.Rituals.Stop.Global) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("  Global:")
                for _, cmd := range cfg.Rituals.Stop.Global </span><span class="cov0" title="0">{
                        fmt.Printf("    - %s: %s\n", cmd.Name, cmd.Command)
                }</span>
        }

        <span class="cov0" title="0">if len(cfg.Rituals.Stop.PerProject) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("  Per-Project:")
                for project, commands := range cfg.Rituals.Stop.PerProject </span><span class="cov0" title="0">{
                        fmt.Printf("    %s:\n", project)
                        for _, cmd := range commands </span><span class="cov0" title="0">{
                                fmt.Printf("      - %s: %s\n", cmd.Name, cmd.Command)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func runRitualTest(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">ritualType := args[0]
        var project string

        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                project = args[1]
        }</span> else<span class="cov0" title="0"> {
                // Auto-detect project
                detector := tracking.NewProjectDetector()
                project = detector.SanitizeProjectName(detector.DetectProject())
        }</span>

        <span class="cov0" title="0">engine := rituals.NewEngine(cfg)
        return engine.TestRitual(ritualType, project)</span>
}

func runRitualRun(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">ritualType := args[0]
        var project string

        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                project = args[1]
        }</span> else<span class="cov0" title="0"> {
                // Auto-detect project
                detector := tracking.NewProjectDetector()
                project = detector.SanitizeProjectName(detector.DetectProject())
        }</span>

        <span class="cov0" title="0">engine := rituals.NewEngine(cfg)

        switch ritualType </span>{
        case "start":<span class="cov0" title="0">
                return engine.ExecuteStartRituals(project)</span>
        case "stop":<span class="cov0" title="0">
                return engine.ExecuteStopRituals(project)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown ritual type: %s (use 'start' or 'stop')", ritualType)</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package commands

import (
        "fmt"
        "os"

        "github.com/ferg-cod3s/rune/internal/config"
        "github.com/ferg-cod3s/rune/internal/telemetry"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        cfgFile string
        version = "dev"
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "rune",
        Short: "Ancient wisdom for modern workflows",
        Long: ` ______     __  __     __   __     ______   
/\  == \   /\ \/\ \   /\ "-.\ \   /\  ___\  
\ \  __&lt;   \ \ \_\ \  \ \ \-.  \  \ \  __\  
 \ \_\ \_\  \ \_____\  \ \_\\"\_\  \ \_____\
  \/_/ /_/   \/_____/   \/_/ \/_/   \/_____/ 

Rune is a developer-first CLI productivity platform that automates daily work 
rituals, enforces healthy work-life boundaries, and integrates seamlessly 
with existing developer workflows.

Cast your daily runes and master your workflow.`,
        Version: version,
}

// Execute adds all child commands to the root command and sets flags appropriately.
func Execute() error <span class="cov0" title="0">{
        return rootCmd.Execute()
}</span>

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig, initTelemetry)

        // Custom version template with logo
        rootCmd.SetVersionTemplate(` ______     __  __     __   __     ______   
/\  == \   /\ \/\ \   /\ "-.\ \   /\  ___\  
\ \  __&lt;   \ \ \_\ \  \ \ \-.  \  \ \  __\  
 \ \_\ \_\  \ \_____\  \ \_\\"\_\  \ \_____\
  \/_/ /_/   \/_____/   \/_/ \/_/   \/_____/ 

version {{.Version}}

`)

        // Global flags
        rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.rune/config.yaml)")
        rootCmd.PersistentFlags().BoolP("verbose", "v", false, "verbose output")

        // Bind flags to viper
        _ = viper.BindPFlag("verbose", rootCmd.PersistentFlags().Lookup("verbose"))
}</span>

// initConfig reads in config file and ENV variables if set.
func initConfig() <span class="cov0" title="0">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                // Use config file from the flag.
                viper.SetConfigFile(cfgFile)
        }</span> else<span class="cov0" title="0"> {
                // Find home directory.
                home, err := os.UserHomeDir()
                cobra.CheckErr(err)

                // Search config in home directory with name ".rune" (without extension).
                viper.AddConfigPath(home + "/.rune")
                viper.SetConfigType("yaml")
                viper.SetConfigName("config")
        }</span>

        <span class="cov0" title="0">viper.AutomaticEnv() // read in environment variables that match

        // If a config file is found, read it in.
        if err := viper.ReadInConfig(); err == nil </span><span class="cov0" title="0">{
                if viper.GetBool("verbose") </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, "Using config file:", viper.ConfigFileUsed())
                }</span>
        }
}

// initTelemetry initializes telemetry tracking
func initTelemetry() <span class="cov0" title="0">{
        // Get telemetry configuration from environment variables or config
        segmentWriteKey := os.Getenv("RUNE_SEGMENT_WRITE_KEY")
        sentryDSN := os.Getenv("RUNE_SENTRY_DSN")

        if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: initTelemetry called\n")
                fmt.Printf("DEBUG: Env Segment Key: %s\n", segmentWriteKey)
                fmt.Printf("DEBUG: Env Sentry DSN: %s\n", sentryDSN)
        }</span>

        // Try to load from config if environment variables are not set
        <span class="cov0" title="0">if cfg, err := config.Load(); err == nil </span><span class="cov0" title="0">{
                if segmentWriteKey == "" </span><span class="cov0" title="0">{
                        segmentWriteKey = cfg.Integrations.Telemetry.SegmentWriteKey
                }</span>
                <span class="cov0" title="0">if sentryDSN == "" </span><span class="cov0" title="0">{
                        sentryDSN = cfg.Integrations.Telemetry.SentryDSN
                }</span>
                <span class="cov0" title="0">if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: Config loaded - Segment: %s, Sentry: %s\n", cfg.Integrations.Telemetry.SegmentWriteKey, cfg.Integrations.Telemetry.SentryDSN)
                }</span>
        } else<span class="cov0" title="0"> if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: Config load failed: %v\n", err)
        }</span>

        <span class="cov0" title="0">if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: Final keys - Segment: %s, Sentry: %s\n", segmentWriteKey, sentryDSN)
        }</span>

        <span class="cov0" title="0">telemetry.Initialize(segmentWriteKey, sentryDSN)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package commands

import (
        "fmt"

        "github.com/ferg-cod3s/rune/internal/config"
        "github.com/ferg-cod3s/rune/internal/dnd"
        "github.com/ferg-cod3s/rune/internal/notifications"
        "github.com/ferg-cod3s/rune/internal/rituals"
        "github.com/ferg-cod3s/rune/internal/telemetry"
        "github.com/ferg-cod3s/rune/internal/tracking"
        "github.com/spf13/cobra"
)

var startCmd = &amp;cobra.Command{
        Use:   "start [project]",
        Short: "Start your workday and run start rituals",
        Long: `Start your workday timer and execute your configured start rituals.

This command will:
- Begin time tracking for your work session
- Execute global start rituals
- Execute project-specific start rituals (if detected)
- Enable focus mode (Do Not Disturb) if configured

If no project is specified, it will be auto-detected from the current directory.`,
        RunE: runStart,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(startCmd)

        // Wrap command with telemetry
        telemetry.WrapCommand(startCmd, runStart)
}</span>

func runStart(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        fmt.Println("🔮 Casting your start ritual...")

        // Load configuration to get idle threshold
        var tracker *tracking.Tracker
        cfg, configErr := config.Load()
        if configErr != nil </span><span class="cov0" title="0">{
                // Use default tracker if config fails to load
                var err error
                tracker, err = tracking.NewTracker()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize tracker: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Use configured idle threshold
                var err error
                tracker, err = tracking.NewTrackerWithIdleThreshold(cfg.Settings.IdleThreshold)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize tracker: %w", err)
                }</span>
        }
        <span class="cov0" title="0">defer tracker.Close()

        // Determine project name
        var project string
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                // Use provided project name
                project = args[0]
        }</span> else<span class="cov0" title="0"> {
                // Auto-detect project
                detector := tracking.NewProjectDetector()
                project = detector.SanitizeProjectName(detector.DetectProject())
        }</span>

        // Start time tracking
        <span class="cov0" title="0">session, err := tracker.Start(project)
        if err != nil </span><span class="cov0" title="0">{
                telemetry.TrackError(err, "start", map[string]interface{}{
                        "project": project,
                        "step":    "tracker_start",
                })
                return fmt.Errorf("failed to start session: %w", err)
        }</span>

        // Track successful start
        <span class="cov0" title="0">telemetry.Track("session_started", map[string]interface{}{
                "project":       project,
                "auto_detected": len(args) == 0,
        })

        // Load configuration and execute start rituals (reuse cfg if already loaded)
        if cfg == nil </span><span class="cov0" title="0">{
                var err error
                cfg, err = config.Load()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("⚠ Could not load config for rituals: %v\n", err)
                }</span>
        }
        <span class="cov0" title="0">if cfg != nil </span><span class="cov0" title="0">{
                engine := rituals.NewEngine(cfg)
                if err := engine.ExecuteStartRituals(project); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("⚠ Start rituals failed: %v\n", err)
                }</span>
        }

        // Check and enable Do Not Disturb if configured
        // Create notification manager based on config
        <span class="cov0" title="0">var notificationEnabled bool
        if cfg != nil </span><span class="cov0" title="0">{
                notificationEnabled = cfg.Settings.Notifications.Enabled
        }</span>

        <span class="cov0" title="0">nm := notifications.NewNotificationManager(notificationEnabled)
        dndManager := dnd.NewDNDManager(nm)

        // Check if shortcuts are properly set up
        shortcutsReady, shortcutsErr := dndManager.CheckShortcutsSetup()
        if shortcutsErr != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠ Could not check Focus mode shortcuts: %v\n", shortcutsErr)
        }</span> else<span class="cov0" title="0"> if !shortcutsReady </span><span class="cov0" title="0">{
                fmt.Println("⚠ Focus mode shortcuts not set up")
                fmt.Println("💡 To enable automatic Focus mode control:")
                fmt.Println("   1. Open Shortcuts app")
                fmt.Println("   2. Create a new shortcut named 'Turn On Do Not Disturb'")
                fmt.Println("   3. Add action: 'Set Focus' → 'Do Not Disturb'")
                fmt.Println("   4. Create another shortcut named 'Turn Off Do Not Disturb'")
                fmt.Println("   5. Add action: 'Set Focus' → 'Turn Off Focus'")
                fmt.Println("   📖 See FOCUS_SETUP.md for detailed instructions")
        }</span> else<span class="cov0" title="0"> {
                // Shortcuts are set up, try to enable Focus mode
                if err := dndManager.Enable(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("⚠ Could not enable Do Not Disturb: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("🎯 Focus mode enabled")
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("✓ Start ritual complete")
        fmt.Printf("⏰ Work timer started for project: %s\n", session.Project)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package commands

import (
        "fmt"

        "github.com/ferg-cod3s/rune/internal/config"
        "github.com/ferg-cod3s/rune/internal/dnd"
        "github.com/ferg-cod3s/rune/internal/notifications"
        "github.com/ferg-cod3s/rune/internal/telemetry"
        "github.com/ferg-cod3s/rune/internal/tracking"
        "github.com/spf13/cobra"
)

var statusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Show current session status",
        Long: `Display the current status of your work session.

This command shows:
- Current timer state (running, paused, stopped)
- Active project (if detected)
- Session duration
- Today's total work time
- Focus mode status`,
        RunE: runStatus,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(statusCmd)

        // Wrap command with telemetry
        telemetry.WrapCommand(statusCmd, runStatus)
}</span>

func runStatus(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        fmt.Println("📊 Current Session Status")
        fmt.Println("========================")
        fmt.Println()

        // Initialize tracker
        tracker, err := tracking.NewTracker()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize tracker: %w", err)
        }</span>
        <span class="cov0" title="0">defer tracker.Close()

        // Get current session
        session, err := tracker.GetCurrentSession()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current session: %w", err)
        }</span>

        <span class="cov0" title="0">if session == nil </span><span class="cov0" title="0">{
                fmt.Println("Timer:        Stopped")
                fmt.Println("Project:      Not detected")
                fmt.Println("Session:      0h 0m")
        }</span> else<span class="cov0" title="0"> {
                duration, err := tracker.GetSessionDuration()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get session duration: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Timer:        %s\n", session.State)
                fmt.Printf("Project:      %s\n", session.Project)
                fmt.Printf("Session:      %s\n", formatDuration(duration))</span>
        }

        // Get daily total
        <span class="cov0" title="0">dailyTotal, err := tracker.GetDailyTotal()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get daily total: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Today Total:  %s\n", formatDuration(dailyTotal))

        // Get idle status
        isIdle, err := tracker.IsIdle()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Idle Status:  Unknown (detection failed)")
        }</span> else<span class="cov0" title="0"> {
                if isIdle </span><span class="cov0" title="0">{
                        idleTime, err := tracker.GetIdleTime()
                        if err == nil </span><span class="cov0" title="0">{
                                fmt.Printf("Idle Status:  Idle for %s\n", formatDuration(idleTime))
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Idle Status:  Idle")
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println("Idle Status:  Active")
                }</span>
        }

        // Check DND status
        <span class="cov0" title="0">cfg, _ := config.Load()
        var notificationEnabled bool
        if cfg != nil </span><span class="cov0" title="0">{
                notificationEnabled = cfg.Settings.Notifications.Enabled
        }</span>

        <span class="cov0" title="0">nm := notifications.NewNotificationManager(notificationEnabled)
        dndManager := dnd.NewDNDManager(nm)
        dndEnabled, err := dndManager.IsEnabled()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Focus Mode:   Unknown (detection failed)")
        }</span> else<span class="cov0" title="0"> {
                if dndEnabled </span><span class="cov0" title="0">{
                        fmt.Println("Focus Mode:   Enabled")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("Focus Mode:   Disabled")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package commands

import (
        "fmt"

        "github.com/ferg-cod3s/rune/internal/config"
        "github.com/ferg-cod3s/rune/internal/dnd"
        "github.com/ferg-cod3s/rune/internal/notifications"
        "github.com/ferg-cod3s/rune/internal/rituals"
        "github.com/ferg-cod3s/rune/internal/telemetry"
        "github.com/ferg-cod3s/rune/internal/tracking"
        "github.com/spf13/cobra"
)

var stopCmd = &amp;cobra.Command{
        Use:   "stop",
        Short: "End your workday and run stop rituals",
        Long: `End your workday timer and execute your configured stop rituals.

This command will:
- Stop time tracking for your work session
- Execute global stop rituals
- Execute project-specific stop rituals (if detected)
- Disable focus mode (Do Not Disturb) if configured
- Generate a summary of your work session`,
        RunE: runStop,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(stopCmd)

        // Wrap command with telemetry
        telemetry.WrapCommand(stopCmd, runStop)
}</span>

func runStop(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        fmt.Println("🔮 Casting your stop ritual...")

        // Initialize tracker
        tracker, err := tracking.NewTracker()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize tracker: %w", err)
        }</span>
        <span class="cov0" title="0">defer tracker.Close()

        // Stop time tracking
        session, err := tracker.Stop()
        if err != nil </span><span class="cov0" title="0">{
                telemetry.TrackError(err, "stop", map[string]interface{}{
                        "step": "tracker_stop",
                })
                return fmt.Errorf("failed to stop session: %w", err)
        }</span>

        // Track successful stop
        <span class="cov0" title="0">telemetry.Track("session_stopped", map[string]interface{}{
                "project":  session.Project,
                "duration": session.Duration.Milliseconds(),
        })

        // Load configuration and execute stop rituals
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠ Could not load config for rituals: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                engine := rituals.NewEngine(cfg)
                if err := engine.ExecuteStopRituals(session.Project); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("⚠ Stop rituals failed: %v\n", err)
                }</span>
        }

        // Disable Do Not Disturb
        <span class="cov0" title="0">var notificationEnabled bool
        if cfg != nil </span><span class="cov0" title="0">{
                notificationEnabled = cfg.Settings.Notifications.Enabled
        }</span>

        <span class="cov0" title="0">nm := notifications.NewNotificationManager(notificationEnabled)
        dndManager := dnd.NewDNDManager(nm)
        if err := dndManager.Disable(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠ Could not disable Do Not Disturb: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("🎯 Focus mode disabled")
        }</span>

        <span class="cov0" title="0">fmt.Println("✓ Stop ritual complete")
        fmt.Println("⏰ Work timer stopped")
        fmt.Printf("📊 Session summary: %s (project: %s)\n",
                formatDuration(session.Duration), session.Project)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package commands

import (
        "fmt"
        "time"

        "github.com/ferg-cod3s/rune/internal/dnd"
        "github.com/ferg-cod3s/rune/internal/notifications"
        "github.com/spf13/cobra"
)

// testCmd represents the test command
var testCmd = &amp;cobra.Command{
        Use:   "test",
        Short: "Test various Rune functionality",
        Long: `Test various Rune functionality including notifications, DND, and integrations.

This command helps verify that your system is properly configured and that
Rune can interact with your operating system as expected.`,
}

// testNotificationsCmd tests the notification system
var testNotificationsCmd = &amp;cobra.Command{
        Use:   "notifications",
        Short: "Test the notification system",
        Long: `Test the notification system to ensure OS-level notifications are working.

This will send various types of test notifications to verify that:
- Basic notifications work
- Break reminders work
- End-of-day reminders work
- Session completion notifications work
- Idle detection notifications work`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                fmt.Println("🧪 Testing notification system...")

                // Check if notifications are supported
                if !notifications.IsSupported() </span><span class="cov0" title="0">{
                        return fmt.Errorf("notifications are not supported on this platform")
                }</span>

                // Create notification manager
                <span class="cov0" title="0">nm := notifications.NewNotificationManager(true)

                // Create DND manager with notifications
                dndManager := dnd.NewDNDManager(nm)

                fmt.Println("📱 Sending test notification...")
                if err := dndManager.TestNotifications(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Test notification failed: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("✅ Test notification sent successfully")
                }</span>

                // Wait a moment between notifications
                <span class="cov0" title="0">time.Sleep(2 * time.Second)

                fmt.Println("🧘 Testing break reminder...")
                if err := dndManager.SendBreakNotification(45 * time.Minute); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Break reminder failed: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("✅ Break reminder sent successfully")
                }</span>

                <span class="cov0" title="0">time.Sleep(2 * time.Second)

                fmt.Println("🌅 Testing end-of-day reminder...")
                if err := dndManager.SendEndOfDayNotification(7*time.Hour+30*time.Minute, 8.0); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ End-of-day reminder failed: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("✅ End-of-day reminder sent successfully")
                }</span>

                <span class="cov0" title="0">time.Sleep(2 * time.Second)

                fmt.Println("✅ Testing session complete notification...")
                if err := dndManager.SendSessionCompleteNotification(2*time.Hour, "test-project"); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Session complete notification failed: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("✅ Session complete notification sent successfully")
                }</span>

                <span class="cov0" title="0">time.Sleep(2 * time.Second)

                fmt.Println("💤 Testing idle detection notification...")
                if err := dndManager.SendIdleNotification(10 * time.Minute); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Idle detection notification failed: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("✅ Idle detection notification sent successfully")
                }</span>

                <span class="cov0" title="0">fmt.Println("\n🎉 Notification testing complete!")
                fmt.Println("If you saw notifications appear on your screen, the system is working correctly.")
                fmt.Println("If not, check your system's notification settings and permissions.")

                return nil</span>
        },
}

// testDNDCmd tests the Do Not Disturb functionality
var testDNDCmd = &amp;cobra.Command{
        Use:   "dnd",
        Short: "Test Do Not Disturb functionality",
        Long: `Test Do Not Disturb functionality to ensure Rune can control your system's
focus mode and notification settings.

This will:
- Check if DND is currently enabled
- Test enabling DND
- Test disabling DND
- Check for required shortcuts (macOS)`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                fmt.Println("🔕 Testing Do Not Disturb functionality...")

                // Create DND manager
                nm := notifications.NewNotificationManager(true)
                dndManager := dnd.NewDNDManager(nm)

                // Check current status
                fmt.Println("📊 Checking current DND status...")
                enabled, err := dndManager.IsEnabled()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Failed to check DND status: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("ℹ️  DND is currently: %s\n", map[bool]string{true: "enabled", false: "disabled"}[enabled])
                }</span>

                // Test enabling DND
                <span class="cov0" title="0">fmt.Println("🔕 Testing DND enable...")
                if err := dndManager.Enable(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Failed to enable DND: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("✅ DND enabled successfully")
                }</span>

                // Wait a moment
                <span class="cov0" title="0">time.Sleep(3 * time.Second)

                // Test disabling DND
                fmt.Println("🔔 Testing DND disable...")
                if err := dndManager.Disable(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Failed to disable DND: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("✅ DND disabled successfully")
                }</span>

                // Check shortcuts setup (macOS only)
                <span class="cov0" title="0">fmt.Println("🔧 Checking shortcuts setup...")
                shortcutsOK, err := dndManager.CheckShortcutsSetup()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Failed to check shortcuts: %v\n", err)
                }</span> else<span class="cov0" title="0"> if shortcutsOK </span><span class="cov0" title="0">{
                        fmt.Println("✅ Required shortcuts are properly configured")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("⚠️  Some shortcuts may need to be configured manually")
                }</span>

                <span class="cov0" title="0">fmt.Println("\n🎉 DND testing complete!")
                return nil</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(testCmd)
        testCmd.AddCommand(testNotificationsCmd)
        testCmd.AddCommand(testDNDCmd)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package commands

import (
        "archive/tar"
        "archive/zip"
        "compress/gzip"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "time"

        "github.com/spf13/cobra"
)

type GitHubRelease struct {
        TagName string `json:"tag_name"`
        Name    string `json:"name"`
        Assets  []struct {
                Name               string `json:"name"`
                BrowserDownloadURL string `json:"browser_download_url"`
        } `json:"assets"`
}

var updateCmd = &amp;cobra.Command{
        Use:   "update",
        Short: "Update rune to the latest version",
        Long: `Update rune to the latest version from GitHub releases.

This command will:
- Check for the latest version on GitHub
- Download and install the update if a newer version is available
- Preserve your current configuration

Examples:
  rune update              # Check and update to latest version
  rune update --check      # Only check for updates without installing`,
        RunE: runUpdate,
}

var (
        checkOnly bool
)

func init() <span class="cov1" title="1">{
        rootCmd.AddCommand(updateCmd)
        updateCmd.Flags().BoolVar(&amp;checkOnly, "check", false, "Only check for updates without installing")
}</span>

func runUpdate(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        fmt.Println("🔍 Checking for updates...")

        // Get current version
        currentVersion := version
        if currentVersion == "dev" </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot update development builds - please install from releases")
        }</span>

        // Fetch latest release info
        <span class="cov0" title="0">latestRelease, err := getLatestRelease()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check for updates: %w", err)
        }</span>

        // Compare versions
        <span class="cov0" title="0">if !isNewerVersion(latestRelease.TagName, currentVersion) </span><span class="cov0" title="0">{
                fmt.Printf("✅ You're already running the latest version (%s)\n", currentVersion)
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("🆕 New version available: %s (current: %s)\n", latestRelease.TagName, currentVersion)

        if checkOnly </span><span class="cov0" title="0">{
                fmt.Println("💡 Run 'rune update' to install the latest version")
                return nil
        }</span>

        // Find appropriate asset for current platform
        <span class="cov0" title="0">assetURL, err := findAssetForPlatform(latestRelease)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find download for your platform: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("⬇️  Downloading %s...\n", latestRelease.TagName)

        // Download and install
        if err := downloadAndInstall(assetURL, latestRelease.TagName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install update: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Successfully updated to %s!\n", latestRelease.TagName)
        fmt.Println("💡 Run 'rune --version' to verify the update")

        return nil</span>
}

func getLatestRelease() (*GitHubRelease, error) <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Get("https://api.github.com/repos/ferg-cod3s/rune/releases/latest")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GitHub API returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var release GitHubRelease
        if err := json.NewDecoder(resp.Body).Decode(&amp;release); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;release, nil</span>
}

func isNewerVersion(latest, current string) bool <span class="cov10" title="5">{
        // Remove 'v' prefix if present
        latest = strings.TrimPrefix(latest, "v")
        current = strings.TrimPrefix(current, "v")

        // Simple string comparison for now - in production you'd want proper semver comparison
        return latest != current
}</span>

func findAssetForPlatform(release *GitHubRelease) (string, error) <span class="cov1" title="1">{
        osName := runtime.GOOS
        arch := runtime.GOARCH

        // Map Go arch names to release asset names
        archMap := map[string]string{
                "amd64": "x86_64",
                "arm64": "arm64",
        }

        if mappedArch, ok := archMap[arch]; ok </span><span class="cov1" title="1">{
                arch = mappedArch
        }</span>

        // Map Go OS names to release asset names
        <span class="cov1" title="1">osMap := map[string]string{
                "darwin":  "Darwin",
                "linux":   "Linux",
                "windows": "Windows",
        }

        if mappedOS, ok := osMap[osName]; ok </span><span class="cov1" title="1">{
                osName = mappedOS
        }</span>

        // Look for matching asset
        <span class="cov1" title="1">expectedPattern := fmt.Sprintf("rune_%s_%s", osName, arch)

        for _, asset := range release.Assets </span><span class="cov4" title="2">{
                if strings.Contains(asset.Name, expectedPattern) </span><span class="cov1" title="1">{
                        return asset.BrowserDownloadURL, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no release found for %s/%s", osName, arch)</span>
}

func downloadAndInstall(url, version string) error <span class="cov0" title="0">{
        // Create temp directory
        tempDir, err := os.MkdirTemp("", "rune-update-*")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer os.RemoveAll(tempDir)

        // Download archive
        client := &amp;http.Client{Timeout: 5 * time.Minute}
        resp, err := client.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("download failed with status %d", resp.StatusCode)
        }</span>

        // Determine archive type and filename
        <span class="cov0" title="0">archivePath := filepath.Join(tempDir, "rune-archive")
        isZip := strings.HasSuffix(url, ".zip")

        if isZip </span><span class="cov0" title="0">{
                archivePath += ".zip"
        }</span> else<span class="cov0" title="0"> {
                archivePath += ".tar.gz"
        }</span>

        // Save archive
        <span class="cov0" title="0">archiveFile, err := os.Create(archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = io.Copy(archiveFile, resp.Body)
        archiveFile.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extract archive
        <span class="cov0" title="0">extractDir := filepath.Join(tempDir, "extracted")
        if err := os.MkdirAll(extractDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if isZip </span><span class="cov0" title="0">{
                err = extractZip(archivePath, extractDir)
        }</span> else<span class="cov0" title="0"> {
                err = extractTarGz(archivePath, extractDir)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Find the rune binary
        <span class="cov0" title="0">binaryName := "rune"
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                binaryName = "rune.exe"
        }</span>

        <span class="cov0" title="0">var newBinaryPath string
        err = filepath.Walk(extractDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if info.Name() == binaryName </span><span class="cov0" title="0">{
                        newBinaryPath = path
                        return filepath.SkipDir
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if newBinaryPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not find %s binary in archive", binaryName)
        }</span>

        // Get current executable path
        <span class="cov0" title="0">currentExe, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Make new binary executable
        <span class="cov0" title="0">if err := os.Chmod(newBinaryPath, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Replace current binary
        // On Windows, we might need to rename the old file first
        <span class="cov0" title="0">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                backupPath := currentExe + ".old"
                if err := os.Rename(currentExe, backupPath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := copyFile(newBinaryPath, currentExe); err != nil </span><span class="cov0" title="0">{
                        // Try to restore backup
                        if restoreErr := os.Rename(backupPath, currentExe); restoreErr != nil </span><span class="cov0" title="0">{
                                // Log the restore error but return the original error
                                fmt.Fprintf(os.Stderr, "Warning: failed to restore backup: %v\n", restoreErr)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">if err := os.Remove(backupPath); err != nil </span><span class="cov0" title="0">{
                        // Log warning but don't fail the update
                        fmt.Fprintf(os.Stderr, "Warning: failed to remove backup file: %v\n", err)
                }</span>
        } else<span class="cov0" title="0"> {
                if err := copyFile(newBinaryPath, currentExe); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func extractZip(src, dest string) error <span class="cov0" title="0">{
        r, err := zip.OpenReader(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer r.Close()

        for _, f := range r.File </span><span class="cov0" title="0">{
                path := filepath.Join(dest, f.Name)

                if f.FileInfo().IsDir() </span><span class="cov0" title="0">{
                        if err := os.MkdirAll(path, f.FileInfo().Mode()); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">rc, err := f.Open()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">outFile, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.FileInfo().Mode())
                if err != nil </span><span class="cov0" title="0">{
                        rc.Close()
                        return err
                }</span>

                <span class="cov0" title="0">_, err = io.Copy(outFile, rc)
                outFile.Close()
                rc.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func extractTarGz(src, dest string) error <span class="cov0" title="0">{
        file, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        gzr, err := gzip.NewReader(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer gzr.Close()

        tr := tar.NewReader(gzr)

        for </span><span class="cov0" title="0">{
                header, err := tr.Next()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">path := filepath.Join(dest, header.Name)

                switch header.Typeflag </span>{
                case tar.TypeDir:<span class="cov0" title="0">
                        if err := os.MkdirAll(path, 0755); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case tar.TypeReg:<span class="cov0" title="0">
                        if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">outFile, err := os.Create(path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if _, err := io.Copy(outFile, tr); err != nil </span><span class="cov0" title="0">{
                                outFile.Close()
                                return err
                        }</span>
                        <span class="cov0" title="0">outFile.Close()

                        if err := os.Chmod(path, os.FileMode(header.Mode)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func copyFile(src, dst string) error <span class="cov0" title="0">{
        sourceFile, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sourceFile.Close()

        destFile, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer destFile.Close()

        if _, err := io.Copy(destFile, sourceFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Copy permissions
        <span class="cov0" title="0">sourceInfo, err := os.Stat(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.Chmod(dst, sourceInfo.Mode())</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package commands

import (
        "fmt"
        "time"
)

// formatDuration formats a duration as "Xh Ym"
func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        hours := int(d.Hours())
        minutes := int(d.Minutes()) % 60
        return fmt.Sprintf("%dh %dm", hours, minutes)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/spf13/viper"
)

// Config represents the main configuration structure
type Config struct {
        Version      int          `yaml:"version" mapstructure:"version"`
        UserID       string       `yaml:"user_id" mapstructure:"user_id"`
        Settings     Settings     `yaml:"settings" mapstructure:"settings"`
        Projects     []Project    `yaml:"projects" mapstructure:"projects"`
        Rituals      Rituals      `yaml:"rituals" mapstructure:"rituals"`
        Integrations Integrations `yaml:"integrations" mapstructure:"integrations"`
}

// Settings contains global application settings
type Settings struct {
        WorkHours     float64              `yaml:"work_hours" mapstructure:"work_hours"`
        BreakInterval time.Duration        `yaml:"break_interval" mapstructure:"break_interval"`
        IdleThreshold time.Duration        `yaml:"idle_threshold" mapstructure:"idle_threshold"`
        Notifications NotificationSettings `yaml:"notifications" mapstructure:"notifications"`
}

// NotificationSettings contains notification preferences
type NotificationSettings struct {
        Enabled           bool `yaml:"enabled" mapstructure:"enabled"`
        BreakReminders    bool `yaml:"break_reminders" mapstructure:"break_reminders"`
        EndOfDayReminders bool `yaml:"end_of_day_reminders" mapstructure:"end_of_day_reminders"`
        SessionComplete   bool `yaml:"session_complete" mapstructure:"session_complete"`
        IdleDetection     bool `yaml:"idle_detection" mapstructure:"idle_detection"`
        Sound             bool `yaml:"sound" mapstructure:"sound"`
}

// Project represents a project configuration
type Project struct {
        Name   string   `yaml:"name" mapstructure:"name"`
        Detect []string `yaml:"detect" mapstructure:"detect"`
}

// Rituals contains start and stop ritual configurations
type Rituals struct {
        Start RitualSet `yaml:"start" mapstructure:"start"`
        Stop  RitualSet `yaml:"stop" mapstructure:"stop"`
}

// RitualSet contains global and per-project rituals
type RitualSet struct {
        Global     []Command            `yaml:"global" mapstructure:"global"`
        PerProject map[string][]Command `yaml:"per_project" mapstructure:"per_project"`
}

// Command represents a ritual command
type Command struct {
        Name       string `yaml:"name" mapstructure:"name"`
        Command    string `yaml:"command" mapstructure:"command"`
        Optional   bool   `yaml:"optional" mapstructure:"optional"`
        Background bool   `yaml:"background" mapstructure:"background"`
}

// Integrations contains external service integrations
type Integrations struct {
        Git       GitIntegration       `yaml:"git" mapstructure:"git"`
        Slack     SlackIntegration     `yaml:"slack" mapstructure:"slack"`
        Calendar  CalendarIntegration  `yaml:"calendar" mapstructure:"calendar"`
        Telemetry TelemetryIntegration `yaml:"telemetry" mapstructure:"telemetry"`
}

// GitIntegration contains Git-related settings
type GitIntegration struct {
        Enabled           bool `yaml:"enabled" mapstructure:"enabled"`
        AutoDetectProject bool `yaml:"auto_detect_project" mapstructure:"auto_detect_project"`
}

// SlackIntegration contains Slack-related settings
type SlackIntegration struct {
        Workspace  string `yaml:"workspace" mapstructure:"workspace"`
        DNDOnStart bool   `yaml:"dnd_on_start" mapstructure:"dnd_on_start"`
}

// CalendarIntegration contains calendar-related settings
type CalendarIntegration struct {
        Provider      string `yaml:"provider" mapstructure:"provider"`
        BlockCalendar bool   `yaml:"block_calendar" mapstructure:"block_calendar"`
}

// TelemetryIntegration contains telemetry-related settings
type TelemetryIntegration struct {
        Enabled         bool   `yaml:"enabled" mapstructure:"enabled"`
        SegmentWriteKey string `yaml:"segment_write_key" mapstructure:"segment_write_key"`
        SentryDSN       string `yaml:"sentry_dsn" mapstructure:"sentry_dsn"`
}

// Load loads the configuration from the default location or specified file
func Load() (*Config, error) <span class="cov0" title="0">{
        var cfg Config

        if err := viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov10" title="8">{
        if c.Version != 1 </span><span class="cov1" title="1">{
                return fmt.Errorf("unsupported config version: %d (expected: 1)", c.Version)
        }</span>

        <span class="cov9" title="7">if c.Settings.WorkHours &lt;= 0 || c.Settings.WorkHours &gt; 24 </span><span class="cov4" title="2">{
                return fmt.Errorf("work_hours must be between 0 and 24, got: %f", c.Settings.WorkHours)
        }</span>

        <span class="cov7" title="5">if c.Settings.BreakInterval &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("break_interval must be positive, got: %v", c.Settings.BreakInterval)
        }</span>

        <span class="cov7" title="4">if c.Settings.IdleThreshold &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("idle_threshold must be positive, got: %v", c.Settings.IdleThreshold)
        }</span>

        // Validate projects
        <span class="cov5" title="3">for i, project := range c.Projects </span><span class="cov5" title="3">{
                if project.Name == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("project[%d]: name cannot be empty", i)
                }</span>
                <span class="cov4" title="2">if len(project.Detect) == 0 </span><span class="cov1" title="1">{
                        return fmt.Errorf("project[%d]: detect patterns cannot be empty", i)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// GetConfigPath returns the path to the configuration file
func GetConfigPath() (string, error) <span class="cov5" title="3">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov5" title="3">return filepath.Join(home, ".rune", "config.yaml"), nil</span>
}

// Exists checks if the configuration file exists
func Exists() (bool, error) <span class="cov4" title="2">{
        configPath, err := GetConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov4" title="2">_, err = os.Stat(configPath)
        if os.IsNotExist(err) </span><span class="cov1" title="1">{
                return false, nil
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check config file: %w", err)
        }</span>

        <span class="cov1" title="1">return true, nil</span>
}

// LoadConfig loads the configuration from file
func LoadConfig() (*Config, error) <span class="cov0" title="0">{
        return Load()
}</span>

// SaveConfig saves the configuration to file
func SaveConfig(cfg *Config) error <span class="cov0" title="0">{
        configPath, err := GetConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Ensure config directory exists
        <span class="cov0" title="0">configDir := filepath.Dir(configPath)
        if err := os.MkdirAll(configDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        <span class="cov0" title="0">viper.Set("version", cfg.Version)
        viper.Set("user_id", cfg.UserID)
        viper.Set("settings", cfg.Settings)
        viper.Set("projects", cfg.Projects)
        viper.Set("rituals", cfg.Rituals)
        viper.Set("integrations", cfg.Integrations)

        return viper.WriteConfigAs(configPath)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package dnd

import (
        "fmt"
        "os/exec"
        "runtime"
        "strings"
        "time"

        "github.com/ferg-cod3s/rune/internal/notifications"
)

// DNDManager handles Do Not Disturb functionality across platforms
type DNDManager struct {
        notificationManager *notifications.NotificationManager
}

// NewDNDManager creates a new DND manager
func NewDNDManager(notificationManager *notifications.NotificationManager) *DNDManager <span class="cov10" title="3">{
        return &amp;DNDManager{
                notificationManager: notificationManager,
        }
}</span>

// Enable enables Do Not Disturb mode
func (d *DNDManager) Enable() error <span class="cov0" title="0">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                return d.enableMacOS()</span>
        case "linux":<span class="cov0" title="0">
                return d.enableLinux()</span>
        case "windows":<span class="cov0" title="0">
                return d.enableWindows()</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("DND not supported on %s", runtime.GOOS)</span>
        }
}

// Disable disables Do Not Disturb mode
func (d *DNDManager) Disable() error <span class="cov0" title="0">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                return d.disableMacOS()</span>
        case "linux":<span class="cov0" title="0">
                return d.disableLinux()</span>
        case "windows":<span class="cov0" title="0">
                return d.disableWindows()</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("DND not supported on %s", runtime.GOOS)</span>
        }
}

// IsEnabled returns true if Do Not Disturb is currently enabled
func (d *DNDManager) IsEnabled() (bool, error) <span class="cov0" title="0">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                return d.isEnabledMacOS()</span>
        case "linux":<span class="cov0" title="0">
                return d.isEnabledLinux()</span>
        case "windows":<span class="cov0" title="0">
                return d.isEnabledWindows()</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("DND not supported on %s", runtime.GOOS)</span>
        }
}

// macOS implementation using modern Focus system
func (d *DNDManager) enableMacOS() error <span class="cov0" title="0">{
        // Method 1: Try using shortcuts if available (user-created shortcuts)
        cmd := exec.Command("shortcuts", "run", "Turn On Do Not Disturb")
        if err := cmd.Run(); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Method 2: Try alternative Focus shortcut names
        <span class="cov0" title="0">focusShortcuts := []string{
                "Set Do Not Disturb",
                "Enable Do Not Disturb",
                "Turn On Focus",
                "Enable Focus Mode",
                "Do Not Disturb On",
        }

        for _, shortcut := range focusShortcuts </span><span class="cov0" title="0">{
                cmd = exec.Command("shortcuts", "run", shortcut)
                if err := cmd.Run(); err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // Method 3: Use AppleScript to access Control Center (requires accessibility permissions)
        <span class="cov0" title="0">script := `
tell application "System Events"
        try
                -- Open Control Center
                tell process "ControlCenter"
                        click menu bar item "Control Center" of menu bar 1
                        delay 0.8
                        
                        -- Look for Focus button in Control Center
                        try
                                click button "Focus" of group 1 of window "Control Center"
                                delay 0.3
                                -- Click on Do Not Disturb option
                                click button "Do Not Disturb" of group 1 of window "Control Center"
                        on error
                                -- Try direct Do Not Disturb button
                                click button "Do Not Disturb" of group 1 of window "Control Center"
                        end try
                        
                        -- Close Control Center by clicking elsewhere
                        key code 53 -- Escape key
                end tell
                return true
        on error errMsg
                -- Close Control Center if it's open
                try
                        key code 53 -- Escape key
                end try
                error errMsg
        end try
end tell
`
        cmd = exec.Command("osascript", "-e", script)
        if err := cmd.Run(); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Method 4: Fallback - return an informative error
        <span class="cov0" title="0">return fmt.Errorf("could not enable Do Not Disturb - please enable it manually or create a Shortcuts automation named 'Turn On Do Not Disturb'")</span>
}

func (d *DNDManager) disableMacOS() error <span class="cov0" title="0">{
        // Method 1: Try using shortcuts if available (user-created shortcuts)
        cmd := exec.Command("shortcuts", "run", "Turn Off Do Not Disturb")
        if err := cmd.Run(); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Method 2: Try alternative Focus shortcut names
        <span class="cov0" title="0">focusShortcuts := []string{
                "Disable Do Not Disturb",
                "Turn Off Focus",
                "Disable Focus Mode",
                "Do Not Disturb Off",
        }

        for _, shortcut := range focusShortcuts </span><span class="cov0" title="0">{
                cmd = exec.Command("shortcuts", "run", shortcut)
                if err := cmd.Run(); err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // Method 3: Use AppleScript to access Control Center (requires accessibility permissions)
        <span class="cov0" title="0">script := `
tell application "System Events"
        try
                -- Open Control Center
                tell process "ControlCenter"
                        click menu bar item "Control Center" of menu bar 1
                        delay 0.8
                        
                        -- Look for Focus button in Control Center and turn it off
                        try
                                click button "Focus" of group 1 of window "Control Center"
                                delay 0.3
                                -- Click to turn off current focus mode
                                click button "Turn Off" of group 1 of window "Control Center"
                        on error
                                -- Try direct Do Not Disturb button to toggle off
                                click button "Do Not Disturb" of group 1 of window "Control Center"
                        end try
                        
                        -- Close Control Center by clicking elsewhere
                        key code 53 -- Escape key
                end tell
                return true
        on error errMsg
                -- Close Control Center if it's open
                try
                        key code 53 -- Escape key
                end try
                error errMsg
        end try
end tell
`
        cmd = exec.Command("osascript", "-e", script)
        if err := cmd.Run(); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Method 4: Fallback - return an informative error
        <span class="cov0" title="0">return fmt.Errorf("could not disable Do Not Disturb - please disable it manually or create a Shortcuts automation named 'Turn Off Do Not Disturb'")</span>
}

func (d *DNDManager) isEnabledMacOS() (bool, error) <span class="cov0" title="0">{
        // Try using shortcuts to check Focus status first
        cmd := exec.Command("shortcuts", "run", "Get Current Focus")
        output, err := cmd.Output()
        if err == nil </span><span class="cov0" title="0">{
                result := strings.TrimSpace(string(output))
                return result != "" &amp;&amp; result != "None" &amp;&amp; result != "Off", nil
        }</span>

        // Fallback: Check using AppleScript to query Focus status
        <span class="cov0" title="0">script := `
tell application "System Events"
        try
                tell process "SystemUIServer"
                        set focusStatus to exists menu bar item "Focus" of menu bar 1
                        if focusStatus then
                                return "true"
                        else
                                return "false"
                        end if
                end tell
        on error
                return "false"
        end try
end tell
`
        cmd = exec.Command("osascript", "-e", script)
        output, err = cmd.Output()
        if err == nil </span><span class="cov0" title="0">{
                return strings.TrimSpace(string(output)) == "true", nil
        }</span>

        // Final fallback: Check using plutil to read the DND plist
        <span class="cov0" title="0">cmd = exec.Command("plutil", "-extract", "dnd_prefs", "xml1", "-o", "-",
                fmt.Sprintf("%s/Library/Preferences/com.apple.ncprefs.plist", getHomeDir()))
        output, err = cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Simple check for DND being enabled
        <span class="cov0" title="0">return strings.Contains(string(output), "&lt;true/&gt;"), nil</span>
}

// Linux implementation using various desktop environments
func (d *DNDManager) enableLinux() error <span class="cov0" title="0">{
        // Try GNOME first
        if err := d.enableGNOME(); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Try KDE
        <span class="cov0" title="0">if err := d.enableKDE(); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Try generic notification daemon
        <span class="cov0" title="0">return d.enableGenericLinux()</span>
}

func (d *DNDManager) disableLinux() error <span class="cov0" title="0">{
        // Try GNOME first
        if err := d.disableGNOME(); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Try KDE
        <span class="cov0" title="0">if err := d.disableKDE(); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Try generic notification daemon
        <span class="cov0" title="0">return d.disableGenericLinux()</span>
}

func (d *DNDManager) isEnabledLinux() (bool, error) <span class="cov0" title="0">{
        // Check GNOME settings
        cmd := exec.Command("gsettings", "get", "org.gnome.desktop.notifications", "show-banners")
        output, err := cmd.Output()
        if err == nil </span><span class="cov0" title="0">{
                return strings.TrimSpace(string(output)) == "false", nil
        }</span>

        // Fallback - assume not enabled if we can't detect
        <span class="cov0" title="0">return false, nil</span>
}

func (d *DNDManager) enableGNOME() error <span class="cov0" title="0">{
        cmd := exec.Command("gsettings", "set", "org.gnome.desktop.notifications", "show-banners", "false")
        return cmd.Run()
}</span>

func (d *DNDManager) disableGNOME() error <span class="cov0" title="0">{
        cmd := exec.Command("gsettings", "set", "org.gnome.desktop.notifications", "show-banners", "true")
        return cmd.Run()
}</span>

func (d *DNDManager) enableKDE() error <span class="cov0" title="0">{
        // KDE uses kwriteconfig5 to modify notification settings
        cmd := exec.Command("kwriteconfig5", "--file", "plasmanotifyrc", "--group", "DoNotDisturb", "--key", "Enabled", "true")
        return cmd.Run()
}</span>

func (d *DNDManager) disableKDE() error <span class="cov0" title="0">{
        cmd := exec.Command("kwriteconfig5", "--file", "plasmanotifyrc", "--group", "DoNotDisturb", "--key", "Enabled", "false")
        return cmd.Run()
}</span>

func (d *DNDManager) enableGenericLinux() error <span class="cov0" title="0">{
        // Try to pause notification daemon
        cmd := exec.Command("notify-send", "--urgency=critical", "--expire-time=1", "DND Enabled")
        return cmd.Run()
}</span>

func (d *DNDManager) disableGenericLinux() error <span class="cov0" title="0">{
        cmd := exec.Command("notify-send", "--urgency=normal", "--expire-time=1", "DND Disabled")
        return cmd.Run()
}</span>

// Windows implementation using Focus Assist
func (d *DNDManager) enableWindows() error <span class="cov0" title="0">{
        // Use PowerShell to enable Focus Assist
        script := `
$registryPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\CloudStore\Store\Cache\DefaultAccount"
$name = "Current"
$value = 1
Set-ItemProperty -Path $registryPath -Name $name -Value $value -Force
`
        cmd := exec.Command("powershell", "-Command", script)
        return cmd.Run()
}</span>

func (d *DNDManager) disableWindows() error <span class="cov0" title="0">{
        script := `
$registryPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\CloudStore\Store\Cache\DefaultAccount"
$name = "Current"
$value = 0
Set-ItemProperty -Path $registryPath -Name $name -Value $value -Force
`
        cmd := exec.Command("powershell", "-Command", script)
        return cmd.Run()
}</span>

func (d *DNDManager) isEnabledWindows() (bool, error) <span class="cov0" title="0">{
        script := `
$registryPath = "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\CloudStore\Store\Cache\DefaultAccount"
$name = "Current"
try {
    $value = Get-ItemProperty -Path $registryPath -Name $name -ErrorAction Stop
    Write-Output $value.Current
} catch {
    Write-Output "0"
}
`
        cmd := exec.Command("powershell", "-Command", script)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(output)) == "1", nil</span>
}

// CheckShortcutsSetup verifies if the required Focus mode shortcuts are available
func (d *DNDManager) CheckShortcutsSetup() (bool, error) <span class="cov0" title="0">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                return d.checkShortcutsMacOS()</span>
        case "linux":<span class="cov0" title="0">
                // Linux doesn't use shortcuts, so always return true
                return true, nil</span>
        case "windows":<span class="cov0" title="0">
                // Windows doesn't use shortcuts, so always return true
                return true, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("shortcuts check not supported on %s", runtime.GOOS)</span>
        }
}

func (d *DNDManager) checkShortcutsMacOS() (bool, error) <span class="cov0" title="0">{
        // Check if the primary shortcuts exist
        requiredShortcuts := []string{
                "Turn On Do Not Disturb",
                "Turn Off Do Not Disturb",
        }

        for _, shortcut := range requiredShortcuts </span><span class="cov0" title="0">{
                cmd := exec.Command("shortcuts", "list")
                output, err := cmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("failed to list shortcuts: %w", err)
                }</span>

                <span class="cov0" title="0">if !strings.Contains(string(output), shortcut) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

// SendBreakNotification sends a break reminder notification
func (d *DNDManager) SendBreakNotification(workDuration time.Duration) error <span class="cov6" title="2">{
        if d.notificationManager == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">return d.notificationManager.SendBreakReminder(workDuration)</span>
}

// SendEndOfDayNotification sends an end-of-day reminder notification
func (d *DNDManager) SendEndOfDayNotification(totalTime time.Duration, targetHours float64) error <span class="cov6" title="2">{
        if d.notificationManager == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">return d.notificationManager.SendEndOfDayReminder(totalTime, targetHours)</span>
}

// SendSessionCompleteNotification sends a session completion notification
func (d *DNDManager) SendSessionCompleteNotification(duration time.Duration, project string) error <span class="cov6" title="2">{
        if d.notificationManager == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">return d.notificationManager.SendSessionComplete(duration, project)</span>
}

// SendIdleNotification sends an idle detection notification
func (d *DNDManager) SendIdleNotification(idleDuration time.Duration) error <span class="cov6" title="2">{
        if d.notificationManager == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">return d.notificationManager.SendIdleDetected(idleDuration)</span>
}

// TestNotifications sends a test notification to verify the system is working
func (d *DNDManager) TestNotifications() error <span class="cov0" title="0">{
        if d.notificationManager == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("notification manager not initialized")
        }</span>
        <span class="cov0" title="0">return d.notificationManager.TestNotification()</span>
}

// Helper function to get home directory
func getHomeDir() string <span class="cov0" title="0">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                return "%USERPROFILE%"
        }</span>
        <span class="cov0" title="0">return "$HOME"</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package notifications

import (
        "fmt"
        "os/exec"
        "runtime"
        "time"
)

// NotificationType represents different types of notifications
type NotificationType int

const (
        BreakReminder NotificationType = iota
        EndOfDayReminder
        SessionComplete
        IdleDetected
        Custom
)

// Priority represents notification priority levels
type Priority int

const (
        Low Priority = iota
        Normal
        High
        Critical
)

// Notification represents a system notification
type Notification struct {
        Title    string
        Message  string
        Type     NotificationType
        Priority Priority
        Sound    bool
        Icon     string
}

// NotificationManager handles cross-platform notifications
type NotificationManager struct {
        enabled bool
}

// NewNotificationManager creates a new notification manager
func NewNotificationManager(enabled bool) *NotificationManager <span class="cov7" title="6">{
        return &amp;NotificationManager{
                enabled: enabled,
        }
}</span>

// Send sends a notification to the OS
func (nm *NotificationManager) Send(notification Notification) error <span class="cov7" title="5">{
        if !nm.enabled </span><span class="cov1" title="1">{
                return nil // Silently skip if notifications are disabled
        }</span>

        <span class="cov6" title="4">switch runtime.GOOS </span>{
        case "darwin":<span class="cov6" title="4">
                return nm.sendMacOS(notification)</span>
        case "linux":<span class="cov0" title="0">
                return nm.sendLinux(notification)</span>
        case "windows":<span class="cov0" title="0">
                return nm.sendWindows(notification)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("notifications not supported on %s", runtime.GOOS)</span>
        }
}

// SendBreakReminder sends a break reminder notification
func (nm *NotificationManager) SendBreakReminder(duration time.Duration) error <span class="cov1" title="1">{
        notification := Notification{
                Title:    "🧘 Time for a Break",
                Message:  fmt.Sprintf("You've been working for %v. Take a short break to recharge!", formatDuration(duration)),
                Type:     BreakReminder,
                Priority: Normal,
                Sound:    true,
                Icon:     "break",
        }
        return nm.Send(notification)
}</span>

// SendEndOfDayReminder sends an end-of-day reminder notification
func (nm *NotificationManager) SendEndOfDayReminder(totalTime time.Duration, targetHours float64) error <span class="cov1" title="1">{
        var message string
        if totalTime.Hours() &gt;= targetHours </span><span class="cov0" title="0">{
                message = fmt.Sprintf("Great work! You've completed %v today. Time to wrap up and enjoy your evening!", formatDuration(totalTime))
        }</span> else<span class="cov1" title="1"> {
                remaining := time.Duration(targetHours*float64(time.Hour)) - totalTime
                message = fmt.Sprintf("You've worked %v today. Consider wrapping up soon - %v remaining to reach your target.", formatDuration(totalTime), formatDuration(remaining))
        }</span>

        <span class="cov1" title="1">notification := Notification{
                Title:    "🌅 End of Workday",
                Message:  message,
                Type:     EndOfDayReminder,
                Priority: High,
                Sound:    true,
                Icon:     "workday",
        }
        return nm.Send(notification)</span>
}

// SendSessionComplete sends a session completion notification
func (nm *NotificationManager) SendSessionComplete(duration time.Duration, project string) error <span class="cov1" title="1">{
        notification := Notification{
                Title:    "✅ Session Complete",
                Message:  fmt.Sprintf("Finished working on %s for %v. Great job!", project, formatDuration(duration)),
                Type:     SessionComplete,
                Priority: Normal,
                Sound:    false,
                Icon:     "complete",
        }
        return nm.Send(notification)
}</span>

// SendIdleDetected sends an idle detection notification
func (nm *NotificationManager) SendIdleDetected(idleDuration time.Duration) error <span class="cov1" title="1">{
        notification := Notification{
                Title:    "💤 Idle Time Detected",
                Message:  fmt.Sprintf("You've been idle for %v. Should I pause your session?", formatDuration(idleDuration)),
                Type:     IdleDetected,
                Priority: Normal,
                Sound:    false,
                Icon:     "idle",
        }
        return nm.Send(notification)
}</span>

// macOS implementation using osascript
func (nm *NotificationManager) sendMacOS(notification Notification) error <span class="cov6" title="4">{
        script := fmt.Sprintf(`
display notification "%s" with title "%s" sound name "%s"
`, notification.Message, notification.Title, nm.getSoundName(notification))

        cmd := exec.Command("osascript", "-e", script)
        return cmd.Run()
}</span>

// Linux implementation using notify-send
func (nm *NotificationManager) sendLinux(notification Notification) error <span class="cov0" title="0">{
        args := []string{
                "notify-send",
                "--urgency=" + nm.getUrgencyLevel(notification.Priority),
                "--expire-time=5000", // 5 seconds
        }

        if notification.Icon != "" </span><span class="cov0" title="0">{
                args = append(args, "--icon="+nm.getIconPath(notification.Icon))
        }</span>

        <span class="cov0" title="0">args = append(args, notification.Title, notification.Message)

        cmd := exec.Command(args[0], args[1:]...)
        return cmd.Run()</span>
}

// Windows implementation using PowerShell
func (nm *NotificationManager) sendWindows(notification Notification) error <span class="cov0" title="0">{
        script := fmt.Sprintf(`
[Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null
[Windows.UI.Notifications.ToastNotification, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null
[Windows.Data.Xml.Dom.XmlDocument, Windows.Data.Xml.Dom.XmlDocument, ContentType = WindowsRuntime] | Out-Null

$template = @"
&lt;toast&gt;
    &lt;visual&gt;
        &lt;binding template="ToastGeneric"&gt;
            &lt;text&gt;%s&lt;/text&gt;
            &lt;text&gt;%s&lt;/text&gt;
        &lt;/binding&gt;
    &lt;/visual&gt;
&lt;/toast&gt;
"@

$xml = New-Object Windows.Data.Xml.Dom.XmlDocument
$xml.LoadXml($template)
$toast = New-Object Windows.UI.Notifications.ToastNotification $xml
[Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier("Rune CLI").Show($toast)
`, notification.Title, notification.Message)

        cmd := exec.Command("powershell", "-Command", script)
        return cmd.Run()
}</span>

// Helper functions

func (nm *NotificationManager) getSoundName(notification Notification) string <span class="cov8" title="8">{
        if !notification.Sound </span><span class="cov5" title="3">{
                return ""
        }</span>

        <span class="cov7" title="5">switch notification.Priority </span>{
        case Critical:<span class="cov1" title="1">
                return "Basso"</span>
        case High:<span class="cov3" title="2">
                return "Ping"</span>
        default:<span class="cov3" title="2">
                return "default"</span>
        }
}

func (nm *NotificationManager) getUrgencyLevel(priority Priority) string <span class="cov6" title="4">{
        switch priority </span>{
        case Critical:<span class="cov1" title="1">
                return "critical"</span>
        case High:<span class="cov1" title="1">
                return "normal"</span>
        case Low:<span class="cov1" title="1">
                return "low"</span>
        default:<span class="cov1" title="1">
                return "normal"</span>
        }
}

func (nm *NotificationManager) getIconPath(iconName string) string <span class="cov0" title="0">{
        // Map icon names to system icons or custom paths
        iconMap := map[string]string{
                "break":    "appointment-soon",
                "workday":  "appointment-missed",
                "complete": "emblem-default",
                "idle":     "appointment-soon",
        }

        if icon, exists := iconMap[iconName]; exists </span><span class="cov0" title="0">{
                return icon
        }</span>
        <span class="cov0" title="0">return "dialog-information"</span>
}

// formatDuration formats a duration in a human-readable way
func formatDuration(d time.Duration) string <span class="cov10" title="11">{
        if d &lt; time.Minute </span><span class="cov1" title="1">{
                return fmt.Sprintf("%d seconds", int(d.Seconds()))
        }</span>
        <span class="cov9" title="10">if d &lt; time.Hour </span><span class="cov7" title="5">{
                minutes := int(d.Minutes())
                return fmt.Sprintf("%d minutes", minutes)
        }</span>
        <span class="cov7" title="5">hours := int(d.Hours())
        minutes := int(d.Minutes()) % 60
        if minutes == 0 </span><span class="cov3" title="2">{
                return fmt.Sprintf("%d hours", hours)
        }</span>
        <span class="cov5" title="3">return fmt.Sprintf("%d hours %d minutes", hours, minutes)</span>
}

// IsSupported returns true if notifications are supported on the current platform
func IsSupported() bool <span class="cov1" title="1">{
        switch runtime.GOOS </span>{
        case "darwin", "linux", "windows":<span class="cov1" title="1">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// TestNotification sends a test notification to verify the system is working
func (nm *NotificationManager) TestNotification() error <span class="cov0" title="0">{
        notification := Notification{
                Title:    "🧪 Rune Test Notification",
                Message:  "If you can see this, notifications are working correctly!",
                Type:     Custom,
                Priority: Normal,
                Sound:    true,
                Icon:     "complete",
        }
        return nm.Send(notification)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package rituals

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "strings"
        "time"

        "github.com/ferg-cod3s/rune/internal/config"
)

// Engine handles ritual execution
type Engine struct {
        config *config.Config
}

// NewEngine creates a new ritual engine
func NewEngine(cfg *config.Config) *Engine <span class="cov0" title="0">{
        return &amp;Engine{
                config: cfg,
        }
}</span>

// ExecuteStartRituals executes start rituals for the given project
func (e *Engine) ExecuteStartRituals(project string) error <span class="cov0" title="0">{
        fmt.Println("🔮 Executing start rituals...")

        // Execute global start rituals
        if err := e.executeCommands(e.config.Rituals.Start.Global, "global"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute global start rituals: %w", err)
        }</span>

        // Execute project-specific start rituals
        <span class="cov0" title="0">if projectCommands, exists := e.config.Rituals.Start.PerProject[project]; exists </span><span class="cov0" title="0">{
                if err := e.executeCommands(projectCommands, project); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute project start rituals: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ExecuteStopRituals executes stop rituals for the given project
func (e *Engine) ExecuteStopRituals(project string) error <span class="cov0" title="0">{
        fmt.Println("🔮 Executing stop rituals...")

        // Execute project-specific stop rituals first
        if projectCommands, exists := e.config.Rituals.Stop.PerProject[project]; exists </span><span class="cov0" title="0">{
                if err := e.executeCommands(projectCommands, project); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute project stop rituals: %w", err)
                }</span>
        }

        // Execute global stop rituals
        <span class="cov0" title="0">if err := e.executeCommands(e.config.Rituals.Stop.Global, "global"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute global stop rituals: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// executeCommands executes a list of commands
func (e *Engine) executeCommands(commands []config.Command, scope string) error <span class="cov0" title="0">{
        for _, cmd := range commands </span><span class="cov0" title="0">{
                if err := e.executeCommand(cmd, scope); err != nil </span><span class="cov0" title="0">{
                        if cmd.Optional </span><span class="cov0" title="0">{
                                fmt.Printf("⚠ Optional command failed: %s (%v)\n", cmd.Name, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("command '%s' failed: %w", cmd.Name, err)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// executeCommand executes a single command
func (e *Engine) executeCommand(cmd config.Command, _ string) error <span class="cov0" title="0">{
        fmt.Printf("  ⚡ %s...", cmd.Name)

        // Create context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Parse command and arguments
        parts := strings.Fields(cmd.Command)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("empty command")
        }</span>

        // Create the command
        <span class="cov0" title="0">execCmd := exec.CommandContext(ctx, parts[0], parts[1:]...)

        // Set up environment
        execCmd.Env = os.Environ()

        if cmd.Background </span><span class="cov0" title="0">{
                // For background commands, just start them
                if err := execCmd.Start(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf(" ❌\n")
                        return err
                }</span>
                <span class="cov0" title="0">fmt.Printf(" ✓ (background)\n")
                return nil</span>
        }

        // For foreground commands, wait for completion
        <span class="cov0" title="0">output, err := execCmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf(" ❌\n")
                if len(output) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("    Output: %s\n", strings.TrimSpace(string(output)))
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Printf(" ✓\n")

        // Show output if verbose mode is enabled
        if len(output) &gt; 0 &amp;&amp; shouldShowOutput(string(output)) </span><span class="cov0" title="0">{
                fmt.Printf("    %s\n", strings.TrimSpace(string(output)))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// shouldShowOutput determines if command output should be displayed
func shouldShowOutput(output string) bool <span class="cov0" title="0">{
        // Don't show empty output or common uninteresting outputs
        output = strings.TrimSpace(output)
        if output == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Skip common Git outputs that aren't useful
        <span class="cov0" title="0">skipPatterns := []string{
                "Already up to date",
                "nothing to commit, working tree clean",
        }

        for _, pattern := range skipPatterns </span><span class="cov0" title="0">{
                if strings.Contains(output, pattern) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// TestRitual tests a ritual without executing it
func (e *Engine) TestRitual(ritualType string, project string) error <span class="cov0" title="0">{
        fmt.Printf("🧪 Testing %s ritual for project: %s\n", ritualType, project)

        var commands []config.Command

        switch ritualType </span>{
        case "start":<span class="cov0" title="0">
                commands = append(commands, e.config.Rituals.Start.Global...)
                if projectCommands, exists := e.config.Rituals.Start.PerProject[project]; exists </span><span class="cov0" title="0">{
                        commands = append(commands, projectCommands...)
                }</span>
        case "stop":<span class="cov0" title="0">
                if projectCommands, exists := e.config.Rituals.Stop.PerProject[project]; exists </span><span class="cov0" title="0">{
                        commands = append(commands, projectCommands...)
                }</span>
                <span class="cov0" title="0">commands = append(commands, e.config.Rituals.Stop.Global...)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown ritual type: %s", ritualType)</span>
        }

        <span class="cov0" title="0">if len(commands) == 0 </span><span class="cov0" title="0">{
                fmt.Println("  No commands configured for this ritual")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Println("Commands that would be executed:")
        for i, cmd := range commands </span><span class="cov0" title="0">{
                optional := ""
                background := ""
                if cmd.Optional </span><span class="cov0" title="0">{
                        optional = " (optional)"
                }</span>
                <span class="cov0" title="0">if cmd.Background </span><span class="cov0" title="0">{
                        background = " (background)"
                }</span>
                <span class="cov0" title="0">fmt.Printf("  %d. %s: %s%s%s\n", i+1, cmd.Name, cmd.Command, optional, background)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package telemetry

import (
        "time"

        "github.com/getsentry/sentry-go"
        "github.com/spf13/cobra"
)

var globalClient *Client

// Initialize sets up the global telemetry client
func Initialize(segmentWriteKey, sentryDSN string) <span class="cov8" title="1">{
        globalClient = NewClient(segmentWriteKey, sentryDSN)
}</span>

// TrackCommand tracks command execution
func TrackCommand(command string, duration time.Duration, success bool) <span class="cov8" title="1">{
        if globalClient != nil </span><span class="cov8" title="1">{
                globalClient.TrackCommand(command, duration, success)
        }</span>
}

// TrackError tracks errors
func TrackError(err error, command string, properties map[string]interface{}) <span class="cov8" title="1">{
        if globalClient != nil </span><span class="cov8" title="1">{
                globalClient.TrackError(err, command, properties)
        }</span>
}

// Track tracks custom events
func Track(event string, properties map[string]interface{}) <span class="cov8" title="1">{
        if globalClient != nil </span><span class="cov8" title="1">{
                globalClient.Track(event, properties)
        }</span>
}

// Close closes the global telemetry client
func Close() <span class="cov8" title="1">{
        if globalClient != nil </span><span class="cov8" title="1">{
                globalClient.Close()
                globalClient = nil
        }</span>
}

// WrapCommand wraps a cobra command with telemetry tracking
func WrapCommand(cmd *cobra.Command, originalRun func(cmd *cobra.Command, args []string) error) <span class="cov0" title="0">{
        if originalRun == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                start := time.Now()
                commandName := cmd.CommandPath()

                // Start command tracking for release health
                StartCommand(commandName)

                err := originalRun(cmd, args)

                duration := time.Since(start)
                success := err == nil

                // End command tracking for release health
                EndCommand(commandName, success, duration)

                TrackCommand(commandName, duration, success)

                if err != nil </span><span class="cov0" title="0">{
                        TrackError(err, commandName, map[string]interface{}{
                                "args": args,
                        })
                }</span>

                <span class="cov0" title="0">return err</span>
        }
}

// WrapCommandNoError wraps a cobra command that doesn't return an error
func WrapCommandNoError(cmd *cobra.Command, originalRun func(cmd *cobra.Command, args []string)) <span class="cov0" title="0">{
        if originalRun == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">cmd.Run = func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                start := time.Now()
                commandName := cmd.CommandPath()

                originalRun(cmd, args)

                duration := time.Since(start)
                TrackCommand(commandName, duration, true)
        }</span>
}

// StartTransaction starts a Sentry transaction for performance monitoring
func StartTransaction(name, operation string) *sentry.Span <span class="cov0" title="0">{
        if globalClient != nil </span><span class="cov0" title="0">{
                return globalClient.StartTransaction(name, operation)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CaptureException captures an exception with additional context
func CaptureException(err error, tags map[string]string, extra map[string]interface{}) <span class="cov0" title="0">{
        if globalClient != nil </span><span class="cov0" title="0">{
                globalClient.CaptureException(err, tags, extra)
        }</span>
}

// CaptureMessage captures a message with additional context
func CaptureMessage(message string, level sentry.Level, tags map[string]string) <span class="cov0" title="0">{
        if globalClient != nil </span><span class="cov0" title="0">{
                globalClient.CaptureMessage(message, level, tags)
        }</span>
}

// StartCommand starts tracking a command for release health
func StartCommand(command string) <span class="cov8" title="1">{
        if globalClient != nil </span><span class="cov8" title="1">{
                globalClient.StartCommand(command)
        }</span>
}

// EndCommand ends tracking a command for release health
func EndCommand(command string, success bool, duration time.Duration) <span class="cov8" title="1">{
        if globalClient != nil </span><span class="cov8" title="1">{
                globalClient.EndCommand(command, success, duration)
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package telemetry

import (
        "context"
        "fmt"
        "os"
        "runtime"
        "time"

        "github.com/ferg-cod3s/rune/internal/config"
        "github.com/getsentry/sentry-go"
        "github.com/segmentio/analytics-go/v3"
)

type Client struct {
        segmentClient analytics.Client
        sentryEnabled bool
        enabled       bool
        userID        string
        sessionID     string
}

func NewClient(userSegmentKey, userSentryDSN string) *Client <span class="cov6" title="6">{
        // Check if telemetry is disabled via environment variable or config
        enabled := os.Getenv("RUNE_TELEMETRY_DISABLED") != "true"

        // Debug logging
        if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: Telemetry enabled: %v\n", enabled)
                fmt.Printf("DEBUG: User Segment Key: %s\n", userSegmentKey)
                fmt.Printf("DEBUG: User Sentry DSN: %s\n", userSentryDSN)
                fmt.Printf("DEBUG: Build-time Segment Key: %s\n", segmentWriteKey)
                fmt.Printf("DEBUG: Build-time Sentry DSN: %s\n", sentryDSN)
        }</span>

        // Generate or load user ID (anonymous)
        <span class="cov6" title="6">userID := getUserID()

        // Use build-time keys if user hasn't provided their own
        finalSegmentKey := userSegmentKey
        if finalSegmentKey == "" </span><span class="cov1" title="1">{
                finalSegmentKey = segmentWriteKey
        }</span>

        <span class="cov6" title="6">finalSentryDSN := userSentryDSN
        if finalSentryDSN == "" </span><span class="cov5" title="4">{
                finalSentryDSN = sentryDSN
        }</span>

        // Debug logging for final values
        <span class="cov6" title="6">if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: Final Segment Key: %s\n", finalSegmentKey)
                fmt.Printf("DEBUG: Final Sentry DSN: %s\n", finalSentryDSN)
                fmt.Printf("DEBUG: User ID: %s\n", userID)
        }</span>

        <span class="cov6" title="6">client := &amp;Client{
                enabled:       enabled,
                userID:        userID,
                sentryEnabled: finalSentryDSN != "",
                sessionID:     generateSessionID(),
        }

        // Initialize Segment client if enabled and write key provided
        if enabled &amp;&amp; finalSegmentKey != "" </span><span class="cov5" title="4">{
                if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: Initializing Segment client with key: %s\n", finalSegmentKey)
                }</span>
                <span class="cov5" title="4">segmentClient := analytics.New(finalSegmentKey)
                client.segmentClient = segmentClient</span>
        } else<span class="cov3" title="2"> if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: Segment client not initialized - enabled: %v, key: %s\n", enabled, finalSegmentKey)
        }</span>

        // Initialize Sentry if enabled and DSN provided
        <span class="cov6" title="6">if enabled &amp;&amp; finalSentryDSN != "" </span><span class="cov1" title="1">{
                if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: Initializing Sentry with DSN: %s\n", finalSentryDSN)
                }</span>
                <span class="cov1" title="1">err := sentry.Init(sentry.ClientOptions{
                        Dsn:              finalSentryDSN,
                        Environment:      getEnvironment(),
                        Release:          getVersion(),
                        AttachStacktrace: true,
                        BeforeSend: func(event *sentry.Event, hint *sentry.EventHint) *sentry.Event </span><span class="cov0" title="0">{
                                // Add user context
                                event.User = sentry.User{
                                        ID: userID,
                                }
                                // Add app context
                                event.Contexts["app"] = map[string]interface{}{
                                        "name":    "rune",
                                        "version": getVersion(),
                                }
                                event.Contexts["os"] = map[string]interface{}{
                                        "name":    runtime.GOOS,
                                        "version": getOSVersion(),
                                }
                                return event
                        }</span>,
                })
                <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                        if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                                fmt.Printf("DEBUG: Sentry initialization failed: %v\n", err)
                        }</span>
                        // Silently fail for telemetry initialization
                        <span class="cov0" title="0">client.sentryEnabled = false</span>
                } else<span class="cov1" title="1"> if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: Sentry initialized successfully\n")
                }</span>
        } else<span class="cov6" title="5"> if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: Sentry not initialized - enabled: %v, DSN: %s\n", enabled, finalSentryDSN)
        }</span>

        <span class="cov6" title="6">return client</span>
}

func (c *Client) Track(event string, properties map[string]interface{}) <span class="cov9" title="15">{
        if !c.enabled </span><span class="cov1" title="1">{
                if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: Telemetry disabled, not tracking event: %s\n", event)
                }</span>
                <span class="cov1" title="1">return</span>
        }

        <span class="cov9" title="14">if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: Tracking event: %s\n", event)
        }</span>

        // Add default properties
        <span class="cov9" title="14">if properties == nil </span><span class="cov3" title="2">{
                properties = make(map[string]interface{})
        }</span>

        // Add system context
        <span class="cov9" title="14">properties["app_name"] = "rune"
        properties["app_version"] = getVersion()
        properties["os_name"] = runtime.GOOS
        properties["os_version"] = getOSVersion()

        // Send to Segment if available
        if c.segmentClient != nil </span><span class="cov8" title="10">{
                if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: Sending to Segment: %s\n", event)
                }</span>
                <span class="cov8" title="10">err := c.segmentClient.Enqueue(analytics.Track{
                        UserId:     c.userID,
                        Event:      event,
                        Properties: properties,
                        Timestamp:  time.Now(),
                })
                if err != nil &amp;&amp; os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: Segment enqueue error: %v\n", err)
                }</span>
        } else<span class="cov5" title="4"> if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: Segment client not available for event: %s\n", event)
        }</span>

        // Send to Sentry as breadcrumb for context
        <span class="cov9" title="14">if c.sentryEnabled </span><span class="cov0" title="0">{
                if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: Adding Sentry breadcrumb: %s\n", event)
                }</span>
                <span class="cov0" title="0">sentry.AddBreadcrumb(&amp;sentry.Breadcrumb{
                        Message:   event,
                        Category:  "telemetry",
                        Level:     sentry.LevelInfo,
                        Data:      properties,
                        Timestamp: time.Now(),
                })</span>
        } else<span class="cov9" title="14"> if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: Sentry not enabled for event: %s\n", event)
        }</span>
}

func (c *Client) TrackError(err error, command string, properties map[string]interface{}) <span class="cov4" title="3">{
        if !c.enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="3">if properties == nil </span><span class="cov0" title="0">{
                properties = make(map[string]interface{})
        }</span>

        <span class="cov4" title="3">properties["error"] = err.Error()
        properties["command"] = command
        properties["error_type"] = fmt.Sprintf("%T", err)

        // Track error event in Segment
        c.Track("error", properties)

        // Send to Sentry for error tracking
        if c.sentryEnabled </span><span class="cov0" title="0">{
                sentry.WithScope(func(scope *sentry.Scope) </span><span class="cov0" title="0">{
                        scope.SetTag("command", command)
                        scope.SetContext("error_details", properties)
                        sentry.CaptureException(err)
                }</span>)
        }
}

func (c *Client) TrackCommand(command string, duration time.Duration, success bool) <span class="cov4" title="3">{
        if !c.enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="3">properties := map[string]interface{}{
                "command":  command,
                "duration": duration.Milliseconds(),
                "success":  success,
        }

        c.Track("command_executed", properties)

        // Add performance monitoring to Sentry
        if c.sentryEnabled </span><span class="cov0" title="0">{
                sentry.WithScope(func(scope *sentry.Scope) </span><span class="cov0" title="0">{
                        scope.SetTag("command", command)
                        scope.SetTag("success", fmt.Sprintf("%t", success))
                        scope.SetExtra("duration_ms", duration.Milliseconds())

                        // Create a transaction for performance monitoring
                        ctx := sentry.SetHubOnContext(context.Background(), sentry.CurrentHub())
                        transaction := sentry.StartTransaction(ctx, fmt.Sprintf("command.%s", command))
                        transaction.SetTag("command", command)
                        transaction.SetTag("success", fmt.Sprintf("%t", success))
                        transaction.SetData("duration_ms", duration.Milliseconds())

                        if !success </span><span class="cov0" title="0">{
                                transaction.Status = sentry.SpanStatusInternalError
                                sentry.CaptureMessage(fmt.Sprintf("Command failed: %s", command))
                        }</span> else<span class="cov0" title="0"> {
                                transaction.Status = sentry.SpanStatusOK
                        }</span>
                        <span class="cov0" title="0">transaction.Finish()</span>
                })
        }
}

func (c *Client) Close() <span class="cov4" title="3">{
        if c.segmentClient != nil </span><span class="cov3" title="2">{
                // Flush any pending events before closing
                if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: Flushing Segment events before close\n")
                }</span>
                <span class="cov3" title="2">c.segmentClient.Close()</span>
        }
        <span class="cov4" title="3">if c.sentryEnabled </span><span class="cov0" title="0">{
                if os.Getenv("RUNE_DEBUG") == "true" </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: Flushing Sentry events before close\n")
                }</span>
                <span class="cov0" title="0">sentry.Flush(5 * time.Second)</span> // Increased timeout for better reliability
        }
}

// StartTransaction starts a Sentry transaction for performance monitoring
func (c *Client) StartTransaction(name, operation string) *sentry.Span <span class="cov1" title="1">{
        if !c.sentryEnabled </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">ctx := sentry.SetHubOnContext(context.Background(), sentry.CurrentHub())
        return sentry.StartTransaction(ctx, name)</span>
}

// CaptureException captures an exception with additional context
func (c *Client) CaptureException(err error, tags map[string]string, extra map[string]interface{}) <span class="cov1" title="1">{
        if !c.sentryEnabled </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov0" title="0">sentry.WithScope(func(scope *sentry.Scope) </span><span class="cov0" title="0">{
                for key, value := range tags </span><span class="cov0" title="0">{
                        scope.SetTag(key, value)
                }</span>
                <span class="cov0" title="0">for key, value := range extra </span><span class="cov0" title="0">{
                        scope.SetExtra(key, value)
                }</span>
                <span class="cov0" title="0">sentry.CaptureException(err)</span>
        })
}

// CaptureMessage captures a message with additional context
func (c *Client) CaptureMessage(message string, level sentry.Level, tags map[string]string) <span class="cov0" title="0">{
        if !c.sentryEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">sentry.WithScope(func(scope *sentry.Scope) </span><span class="cov0" title="0">{
                scope.SetLevel(level)
                for key, value := range tags </span><span class="cov0" title="0">{
                        scope.SetTag(key, value)
                }</span>
                <span class="cov0" title="0">sentry.CaptureMessage(message)</span>
        })
}

func getUserID() string <span class="cov6" title="6">{
        // Try to get from config first
        cfg, err := config.Load()
        if err == nil &amp;&amp; cfg.UserID != "" </span><span class="cov0" title="0">{
                return cfg.UserID
        }</span>

        // Generate a new anonymous ID
        <span class="cov6" title="6">userID := generateAnonymousID()

        // Try to save it to config
        if cfg != nil </span><span class="cov0" title="0">{
                cfg.UserID = userID
                _ = config.SaveConfig(cfg) // Ignore errors
        }</span>

        <span class="cov6" title="6">return userID</span>
}

func generateAnonymousID() string <span class="cov7" title="8">{
        // Simple anonymous ID generation
        hostname, _ := os.Hostname()
        return fmt.Sprintf("anon_%s_%d", hostname, time.Now().Unix())
}</span>

func generateSessionID() string <span class="cov7" title="8">{
        return fmt.Sprintf("session_%d", time.Now().UnixNano())
}</span>

// StartCommand starts tracking a command execution for release health
func (c *Client) StartCommand(command string) <span class="cov3" title="2">{
        if !c.sentryEnabled </span><span class="cov3" title="2">{
                return
        }</span>

        // Add breadcrumb for command start
        <span class="cov0" title="0">sentry.AddBreadcrumb(&amp;sentry.Breadcrumb{
                Message:   fmt.Sprintf("Command started: %s", command),
                Category:  "command",
                Level:     sentry.LevelInfo,
                Timestamp: time.Now(),
                Data: map[string]interface{}{
                        "command": command,
                        "action":  "start",
                },
        })</span>
}

// EndCommand ends tracking a command execution
func (c *Client) EndCommand(command string, success bool, duration time.Duration) <span class="cov4" title="3">{
        if !c.sentryEnabled </span><span class="cov4" title="3">{
                return
        }</span>

        // Add breadcrumb for command end
        <span class="cov0" title="0">level := sentry.LevelInfo
        if !success </span><span class="cov0" title="0">{
                level = sentry.LevelError
        }</span>

        <span class="cov0" title="0">sentry.AddBreadcrumb(&amp;sentry.Breadcrumb{
                Message:   fmt.Sprintf("Command %s: %s", map[bool]string{true: "completed", false: "failed"}[success], command),
                Category:  "command",
                Level:     level,
                Timestamp: time.Now(),
                Data: map[string]interface{}{
                        "command":     command,
                        "action":      "end",
                        "success":     success,
                        "duration_ms": duration.Milliseconds(),
                },
        })</span>
}

// Build-time variables set via ldflags
var (
        segmentWriteKey string
        sentryDSN       string
)

// Build-time version variable set via ldflags
var version string

func getVersion() string <span class="cov10" title="17">{
        if version != "" </span><span class="cov1" title="1">{
                return version
        }</span>
        <span class="cov9" title="16">return "dev"</span>
}

func getEnvironment() string <span class="cov4" title="3">{
        if env := os.Getenv("RUNE_ENV"); env != "" </span><span class="cov1" title="1">{
                return env
        }</span>
        <span class="cov3" title="2">return "production"</span>
}

func getOSVersion() string <span class="cov9" title="14">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov9" title="14">
                return getMacOSVersion()</span>
        case "linux":<span class="cov0" title="0">
                return getLinuxVersion()</span>
        case "windows":<span class="cov0" title="0">
                return getWindowsVersion()</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

func getMacOSVersion() string <span class="cov9" title="14">{
        // Simple implementation - you might want to use a more robust method
        return "unknown"
}</span>

func getLinuxVersion() string <span class="cov0" title="0">{
        // Simple implementation - you might want to use a more robust method
        return "unknown"
}</span>

func getWindowsVersion() string <span class="cov0" title="0">{
        // Simple implementation - you might want to use a more robust method
        return "unknown"
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package tracking

import (
        "fmt"
        "os/exec"
        "runtime"
        "strconv"
        "strings"
        "time"
)

// IdleDetector handles idle time detection across platforms
type IdleDetector struct {
        threshold time.Duration
}

// NewIdleDetector creates a new idle detector with the given threshold
func NewIdleDetector(threshold time.Duration) *IdleDetector <span class="cov8" title="8">{
        return &amp;IdleDetector{
                threshold: threshold,
        }
}</span>

// GetIdleTime returns the current system idle time
func (id *IdleDetector) GetIdleTime() (time.Duration, error) <span class="cov0" title="0">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                return id.getIdleTimeMacOS()</span>
        case "linux":<span class="cov0" title="0">
                return id.getIdleTimeLinux()</span>
        case "windows":<span class="cov0" title="0">
                return id.getIdleTimeWindows()</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("idle detection not supported on %s", runtime.GOOS)</span>
        }
}

// IsIdle returns true if the system has been idle longer than the threshold
func (id *IdleDetector) IsIdle() (bool, error) <span class="cov0" title="0">{
        idleTime, err := id.GetIdleTime()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return idleTime &gt;= id.threshold, nil</span>
}

// getIdleTimeMacOS gets idle time on macOS using ioreg
func (id *IdleDetector) getIdleTimeMacOS() (time.Duration, error) <span class="cov0" title="0">{
        cmd := exec.Command("ioreg", "-c", "IOHIDSystem")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to run ioreg: %w", err)
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, "HIDIdleTime") </span><span class="cov0" title="0">{
                        // Extract the idle time value
                        parts := strings.Split(line, "=")
                        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">valueStr := strings.TrimSpace(parts[1])
                        // Remove any trailing characters and parse as int64
                        valueStr = strings.TrimSpace(strings.Split(valueStr, " ")[0])

                        idleNanos, err := strconv.ParseInt(valueStr, 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Convert from nanoseconds to duration
                        <span class="cov0" title="0">return time.Duration(idleNanos), nil</span>
                }
        }

        <span class="cov0" title="0">return 0, fmt.Errorf("could not find HIDIdleTime in ioreg output")</span>
}

// getIdleTimeLinux gets idle time on Linux using xprintidle or similar
func (id *IdleDetector) getIdleTimeLinux() (time.Duration, error) <span class="cov0" title="0">{
        // Try xprintidle first (most common)
        cmd := exec.Command("xprintidle")
        output, err := cmd.Output()
        if err == nil </span><span class="cov0" title="0">{
                idleMs, err := strconv.ParseInt(strings.TrimSpace(string(output)), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to parse xprintidle output: %w", err)
                }</span>
                <span class="cov0" title="0">return time.Duration(idleMs) * time.Millisecond, nil</span>
        }

        // Try xssstate as fallback
        <span class="cov0" title="0">cmd = exec.Command("xssstate", "-i")
        output, err = cmd.Output()
        if err == nil </span><span class="cov0" title="0">{
                lines := strings.Split(string(output), "\n")
                for _, line := range lines </span><span class="cov0" title="0">{
                        if strings.Contains(line, "idle:") </span><span class="cov0" title="0">{
                                parts := strings.Fields(line)
                                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                                        idleMs, err := strconv.ParseInt(parts[1], 10, 64)
                                        if err == nil </span><span class="cov0" title="0">{
                                                return time.Duration(idleMs) * time.Millisecond, nil
                                        }</span>
                                }
                        }
                }
        }

        // Try parsing /proc/uptime and /proc/stat as last resort
        <span class="cov0" title="0">return id.getIdleTimeLinuxProc()</span>
}

// getIdleTimeLinuxProc gets idle time from /proc filesystem (less accurate)
func (id *IdleDetector) getIdleTimeLinuxProc() (time.Duration, error) <span class="cov0" title="0">{
        // This is a simplified approach - in practice, calculating true idle time
        // from /proc/stat is complex and not very accurate for user idle detection
        return 0, fmt.Errorf("xprintidle not available and /proc method not implemented")
}</span>

// getIdleTimeWindows gets idle time on Windows using GetLastInputInfo
func (id *IdleDetector) getIdleTimeWindows() (time.Duration, error) <span class="cov0" title="0">{
        // Use PowerShell to call GetLastInputInfo
        script := `
Add-Type @'
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

public struct LASTINPUTINFO {
    public uint cbSize;
    public uint dwTime;
}

public class Win32 {
    [DllImport("user32.dll")]
    public static extern bool GetLastInputInfo(ref LASTINPUTINFO plii);
    
    [DllImport("kernel32.dll")]
    public static extern uint GetTickCount();
}
'@

$lastInputInfo = New-Object LASTINPUTINFO
$lastInputInfo.cbSize = [System.Runtime.InteropServices.Marshal]::SizeOf($lastInputInfo)
[Win32]::GetLastInputInfo([ref]$lastInputInfo)
$idleTime = [Win32]::GetTickCount() - $lastInputInfo.dwTime
Write-Output $idleTime
`

        cmd := exec.Command("powershell", "-Command", script)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get idle time on Windows: %w", err)
        }</span>

        <span class="cov0" title="0">idleMs, err := strconv.ParseInt(strings.TrimSpace(string(output)), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse Windows idle time: %w", err)
        }</span>

        <span class="cov0" title="0">return time.Duration(idleMs) * time.Millisecond, nil</span>
}

// StartIdleMonitoring starts monitoring for idle state changes
func (id *IdleDetector) StartIdleMonitoring(onIdleStart, onIdleEnd func()) chan struct{} <span class="cov10" title="11">{
        stop := make(chan struct{})

        go func() </span><span class="cov10" title="11">{
                ticker := time.NewTicker(30 * time.Second) // Check every 30 seconds
                defer ticker.Stop()

                wasIdle := false

                for </span><span class="cov10" title="11">{
                        select </span>{
                        case &lt;-stop:<span class="cov10" title="11">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                isIdle, err := id.IsIdle()
                                if err != nil </span><span class="cov0" title="0">{
                                        // Log error but continue monitoring
                                        continue</span>
                                }

                                <span class="cov0" title="0">if isIdle &amp;&amp; !wasIdle </span><span class="cov0" title="0">{
                                        // Just became idle
                                        if onIdleStart != nil </span><span class="cov0" title="0">{
                                                onIdleStart()
                                        }</span>
                                        <span class="cov0" title="0">wasIdle = true</span>
                                } else<span class="cov0" title="0"> if !isIdle &amp;&amp; wasIdle </span><span class="cov0" title="0">{
                                        // Just became active
                                        if onIdleEnd != nil </span><span class="cov0" title="0">{
                                                onIdleEnd()
                                        }</span>
                                        <span class="cov0" title="0">wasIdle = false</span>
                                }
                        }
                }
        }()

        <span class="cov10" title="11">return stop</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package tracking

import (
        "bufio"
        "encoding/json"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"
)

// ProjectDetector handles automatic project detection
type ProjectDetector struct{}

// NewProjectDetector creates a new project detector
func NewProjectDetector() *ProjectDetector <span class="cov4" title="4">{
        return &amp;ProjectDetector{}
}</span>

// DetectProject attempts to detect the current project based on working directory
func (pd *ProjectDetector) DetectProject() string <span class="cov4" title="5">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "default"
        }</span>

        // Check for common project indicators
        <span class="cov4" title="5">if pd.hasFile(cwd, "package.json") </span><span class="cov1" title="1">{
                return pd.getProjectNameFromPackageJSON(cwd)
        }</span>

        <span class="cov4" title="4">if pd.hasFile(cwd, "go.mod") </span><span class="cov1" title="1">{
                return pd.getProjectNameFromGoMod(cwd)
        }</span>

        <span class="cov3" title="3">if pd.hasFile(cwd, "Cargo.toml") </span><span class="cov1" title="1">{
                return pd.getProjectNameFromCargoToml(cwd)
        }</span>

        <span class="cov2" title="2">if pd.hasFile(cwd, "pyproject.toml") || pd.hasFile(cwd, "setup.py") </span><span class="cov0" title="0">{
                return pd.getProjectNameFromPython(cwd)
        }</span>

        // Check for git repository
        <span class="cov2" title="2">if pd.isGitRepo(cwd) </span><span class="cov1" title="1">{
                return pd.getProjectNameFromGit(cwd)
        }</span>

        // Fall back to directory name
        <span class="cov1" title="1">return filepath.Base(cwd)</span>
}

// hasFile checks if a file exists in the given directory
func (pd *ProjectDetector) hasFile(dir, filename string) bool <span class="cov10" title="41">{
        _, err := os.Stat(filepath.Join(dir, filename))
        return err == nil
}</span>

// isGitRepo checks if the directory is a git repository
func (pd *ProjectDetector) isGitRepo(dir string) bool <span class="cov4" title="4">{
        return pd.hasFile(dir, ".git") || pd.findGitRoot(dir) != ""
}</span>

// findGitRoot finds the git root directory
func (pd *ProjectDetector) findGitRoot(dir string) string <span class="cov3" title="3">{
        for </span><span class="cov8" title="19">{
                if pd.hasFile(dir, ".git") </span><span class="cov1" title="1">{
                        return dir
                }</span>
                <span class="cov8" title="18">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov2" title="2">{
                        break</span>
                }
                <span class="cov7" title="16">dir = parent</span>
        }
        <span class="cov2" title="2">return ""</span>
}

// getProjectNameFromPackageJSON extracts project name from package.json
func (pd *ProjectDetector) getProjectNameFromPackageJSON(dir string) string <span class="cov1" title="1">{
        packagePath := filepath.Join(dir, "package.json")
        data, err := os.ReadFile(packagePath)
        if err != nil </span><span class="cov0" title="0">{
                return filepath.Base(dir)
        }</span>

        <span class="cov1" title="1">var pkg struct {
                Name string `json:"name"`
        }
        if err := json.Unmarshal(data, &amp;pkg); err != nil </span><span class="cov0" title="0">{
                return filepath.Base(dir)
        }</span>

        <span class="cov1" title="1">if pkg.Name != "" </span><span class="cov1" title="1">{
                return pkg.Name
        }</span>
        <span class="cov0" title="0">return filepath.Base(dir)</span>
}

// getProjectNameFromGoMod extracts project name from go.mod
func (pd *ProjectDetector) getProjectNameFromGoMod(dir string) string <span class="cov1" title="1">{
        goModPath := filepath.Join(dir, "go.mod")
        file, err := os.Open(goModPath)
        if err != nil </span><span class="cov0" title="0">{
                return filepath.Base(dir)
        }</span>
        <span class="cov1" title="1">defer file.Close()

        scanner := bufio.NewScanner(file)
        moduleRegex := regexp.MustCompile(`^module\s+(.+)$`)

        for scanner.Scan() </span><span class="cov1" title="1">{
                line := strings.TrimSpace(scanner.Text())
                if matches := moduleRegex.FindStringSubmatch(line); len(matches) &gt; 1 </span><span class="cov1" title="1">{
                        moduleName := matches[1]
                        // Extract just the project name from the module path
                        parts := strings.Split(moduleName, "/")
                        return parts[len(parts)-1]
                }</span>
        }

        <span class="cov0" title="0">return filepath.Base(dir)</span>
}

// getProjectNameFromCargoToml extracts project name from Cargo.toml
func (pd *ProjectDetector) getProjectNameFromCargoToml(dir string) string <span class="cov1" title="1">{
        cargoPath := filepath.Join(dir, "Cargo.toml")
        file, err := os.Open(cargoPath)
        if err != nil </span><span class="cov0" title="0">{
                return filepath.Base(dir)
        }</span>
        <span class="cov1" title="1">defer file.Close()

        scanner := bufio.NewScanner(file)
        nameRegex := regexp.MustCompile(`name\s*=\s*"([^"]+)"`)
        inPackageSection := false

        for scanner.Scan() </span><span class="cov2" title="2">{
                line := strings.TrimSpace(scanner.Text())

                // Check if we're entering the [package] section
                if line == "[package]" </span><span class="cov1" title="1">{
                        inPackageSection = true
                        continue</span>
                }

                // Check if we're entering a different section
                <span class="cov1" title="1">if strings.HasPrefix(line, "[") &amp;&amp; line != "[package]" </span><span class="cov0" title="0">{
                        inPackageSection = false
                        continue</span>
                }

                // Look for name field in package section
                <span class="cov1" title="1">if inPackageSection </span><span class="cov1" title="1">{
                        if matches := nameRegex.FindStringSubmatch(line); len(matches) &gt; 1 </span><span class="cov1" title="1">{
                                return matches[1]
                        }</span>
                }
        }

        <span class="cov0" title="0">return filepath.Base(dir)</span>
}

// getProjectNameFromPython extracts project name from Python project files
func (pd *ProjectDetector) getProjectNameFromPython(dir string) string <span class="cov0" title="0">{
        // Try pyproject.toml first
        pyprojectPath := filepath.Join(dir, "pyproject.toml")
        if file, err := os.Open(pyprojectPath); err == nil </span><span class="cov0" title="0">{
                defer file.Close()
                scanner := bufio.NewScanner(file)
                nameRegex := regexp.MustCompile(`^name\s*=\s*"([^"]+)"`)

                for scanner.Scan() </span><span class="cov0" title="0">{
                        line := strings.TrimSpace(scanner.Text())
                        if matches := nameRegex.FindStringSubmatch(line); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                                return matches[1]
                        }</span>
                }
        }

        // Fall back to setup.py parsing (basic)
        <span class="cov0" title="0">setupPath := filepath.Join(dir, "setup.py")
        if file, err := os.Open(setupPath); err == nil </span><span class="cov0" title="0">{
                defer file.Close()
                scanner := bufio.NewScanner(file)
                nameRegex := regexp.MustCompile(`name\s*=\s*['"']([^'"]+)['"']`)

                for scanner.Scan() </span><span class="cov0" title="0">{
                        line := strings.TrimSpace(scanner.Text())
                        if matches := nameRegex.FindStringSubmatch(line); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                                return matches[1]
                        }</span>
                }
        }

        <span class="cov0" title="0">return filepath.Base(dir)</span>
}

// getProjectNameFromGit extracts project name from git repository
func (pd *ProjectDetector) getProjectNameFromGit(dir string) string <span class="cov1" title="1">{
        gitRoot := pd.findGitRoot(dir)
        if gitRoot == "" </span><span class="cov0" title="0">{
                return filepath.Base(dir)
        }</span>

        // Try to get remote origin URL
        <span class="cov1" title="1">cmd := exec.Command("git", "remote", "get-url", "origin")
        cmd.Dir = gitRoot
        output, err := cmd.Output()
        if err != nil </span><span class="cov1" title="1">{
                return filepath.Base(gitRoot)
        }</span>

        <span class="cov0" title="0">remoteURL := strings.TrimSpace(string(output))
        if remoteURL != "" </span><span class="cov0" title="0">{
                // Extract project name from git URL
                // Handle both SSH and HTTPS URLs
                if strings.Contains(remoteURL, "github.com") || strings.Contains(remoteURL, "gitlab.com") || strings.Contains(remoteURL, "bitbucket.org") </span><span class="cov0" title="0">{
                        // Remove .git suffix
                        remoteURL = strings.TrimSuffix(remoteURL, ".git")
                        // Extract the last part of the path
                        parts := strings.Split(remoteURL, "/")
                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                return parts[len(parts)-1]
                        }</span>
                }
        }

        <span class="cov0" title="0">return filepath.Base(gitRoot)</span>
}

// SanitizeProjectName cleans up project names
func (pd *ProjectDetector) SanitizeProjectName(name string) string <span class="cov5" title="7">{
        // Remove common prefixes/suffixes
        name = strings.TrimPrefix(name, "github.com/")
        name = strings.TrimSuffix(name, ".git")

        // Replace invalid characters
        name = strings.ReplaceAll(name, "/", "-")
        name = strings.ReplaceAll(name, "\\", "-")
        name = strings.ReplaceAll(name, " ", "-")

        // Convert to lowercase
        name = strings.ToLower(name)

        if name == "" </span><span class="cov1" title="1">{
                return "default"
        }</span>

        <span class="cov5" title="6">return name</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package tracking

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "go.etcd.io/bbolt"
)

// SessionState represents the current state of a work session
type SessionState int

const (
        StateStopped SessionState = iota
        StateRunning
        StatePaused
)

func (s SessionState) String() string <span class="cov5" title="7">{
        switch s </span>{
        case StateStopped:<span class="cov1" title="1">
                return "Stopped"</span>
        case StateRunning:<span class="cov3" title="3">
                return "Running"</span>
        case StatePaused:<span class="cov2" title="2">
                return "Paused"</span>
        default:<span class="cov1" title="1">
                return "Unknown"</span>
        }
}

// Session represents a work session
type Session struct {
        ID        string        `json:"id"`
        Project   string        `json:"project"`
        StartTime time.Time     `json:"start_time"`
        EndTime   *time.Time    `json:"end_time,omitempty"`
        PausedAt  *time.Time    `json:"paused_at,omitempty"`
        Duration  time.Duration `json:"duration"`
        State     SessionState  `json:"state"`
}

// Tracker manages time tracking sessions
type Tracker struct {
        db           *bbolt.DB
        idleDetector *IdleDetector
        idleStop     chan struct{}
}

var (
        sessionsBucket = []byte("sessions")
        currentBucket  = []byte("current")
)

// NewTracker creates a new time tracker
func NewTracker() (*Tracker, error) <span class="cov6" title="8">{
        return NewTrackerWithIdleThreshold(5 * time.Minute)
}</span>

// NewTrackerWithIdleThreshold creates a new time tracker with custom idle threshold
func NewTrackerWithIdleThreshold(idleThreshold time.Duration) (*Tracker, error) <span class="cov6" title="8">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov6" title="8">runeDir := filepath.Join(home, ".rune")
        if err := os.MkdirAll(runeDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create .rune directory: %w", err)
        }</span>

        <span class="cov6" title="8">dbPath := filepath.Join(runeDir, "sessions.db")
        db, err := bbolt.Open(dbPath, 0600, &amp;bbolt.Options{Timeout: 1 * time.Second})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov6" title="8">idleDetector := NewIdleDetector(idleThreshold)

        tracker := &amp;Tracker{
                db:           db,
                idleDetector: idleDetector,
        }
        if err := tracker.initBuckets(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, err
        }</span>

        <span class="cov6" title="8">return tracker, nil</span>
}

// Close closes the tracker and database
func (t *Tracker) Close() error <span class="cov6" title="8">{
        if t.idleStop != nil </span><span class="cov0" title="0">{
                close(t.idleStop)
        }</span>
        <span class="cov6" title="8">return t.db.Close()</span>
}

// initBuckets creates the necessary database buckets
func (t *Tracker) initBuckets() error <span class="cov6" title="8">{
        return t.db.Update(func(tx *bbolt.Tx) error </span><span class="cov6" title="8">{
                if _, err := tx.CreateBucketIfNotExists(sessionsBucket); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="8">if _, err := tx.CreateBucketIfNotExists(currentBucket); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov6" title="8">return nil</span>
        })
}

// Start starts a new work session
func (t *Tracker) Start(project string) (*Session, error) <span class="cov7" title="12">{
        // Check if there's already an active session
        current, err := t.GetCurrentSession()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="12">if current != nil &amp;&amp; current.State != StateStopped </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("session already active (state: %s)", current.State)
        }</span>

        <span class="cov6" title="11">session := &amp;Session{
                ID:        generateSessionID(),
                Project:   project,
                StartTime: time.Now(),
                State:     StateRunning,
        }

        if err := t.saveSession(session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="11">if err := t.setCurrentSession(session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Start idle monitoring when a session starts
        <span class="cov6" title="11">if err := t.StartIdleMonitoring(); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the session start
                fmt.Printf("Warning: Failed to start idle monitoring: %v\n", err)
        }</span>

        <span class="cov6" title="11">return session, nil</span>
}

// Stop stops the current work session
func (t *Tracker) Stop() (*Session, error) <span class="cov7" title="12">{
        session, err := t.GetCurrentSession()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="12">if session == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no active session to stop")
        }</span>

        <span class="cov6" title="11">now := time.Now()
        session.EndTime = &amp;now
        session.State = StateStopped

        // Calculate total duration
        if session.PausedAt != nil </span><span class="cov0" title="0">{
                // If paused, don't include time since pause
                session.Duration = session.PausedAt.Sub(session.StartTime)
        }</span> else<span class="cov6" title="11"> {
                session.Duration = now.Sub(session.StartTime)
        }</span>

        <span class="cov6" title="11">if err := t.saveSession(session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="11">if err := t.clearCurrentSession(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Stop idle monitoring when session stops
        <span class="cov6" title="11">t.StopIdleMonitoring()

        return session, nil</span>
}

// Pause pauses the current work session
func (t *Tracker) Pause() (*Session, error) <span class="cov4" title="4">{
        session, err := t.GetCurrentSession()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="4">if session == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no active session to pause")
        }</span>
        <span class="cov3" title="3">if session.State != StateRunning </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("session is not running (state: %s)", session.State)
        }</span>

        <span class="cov2" title="2">now := time.Now()
        session.PausedAt = &amp;now
        session.State = StatePaused

        if err := t.saveSession(session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">if err := t.setCurrentSession(session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">return session, nil</span>
}

// Resume resumes a paused work session
func (t *Tracker) Resume() (*Session, error) <span class="cov4" title="4">{
        session, err := t.GetCurrentSession()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="4">if session == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no session to resume")
        }</span>
        <span class="cov3" title="3">if session.State != StatePaused </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("session is not paused (state: %s)", session.State)
        }</span>

        // Calculate duration while paused and adjust start time
        <span class="cov2" title="2">pauseDuration := time.Since(*session.PausedAt)
        session.StartTime = session.StartTime.Add(pauseDuration)
        session.PausedAt = nil
        session.State = StateRunning

        if err := t.saveSession(session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">if err := t.setCurrentSession(session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">return session, nil</span>
}

// GetCurrentSession returns the current active session
func (t *Tracker) GetCurrentSession() (*Session, error) <span class="cov10" title="38">{
        var session *Session

        err := t.db.View(func(tx *bbolt.Tx) error </span><span class="cov10" title="38">{
                bucket := tx.Bucket(currentBucket)
                data := bucket.Get([]byte("session"))
                if data == nil </span><span class="cov8" title="17">{
                        return nil
                }</span>

                <span class="cov8" title="21">session = &amp;Session{}
                return json.Unmarshal(data, session)</span>
        })

        <span class="cov10" title="38">return session, err</span>
}

// GetSessionDuration returns the current session duration
func (t *Tracker) GetSessionDuration() (time.Duration, error) <span class="cov4" title="4">{
        session, err := t.GetCurrentSession()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov4" title="4">if session == nil </span><span class="cov2" title="2">{
                return 0, nil
        }</span>

        <span class="cov2" title="2">switch session.State </span>{
        case StateRunning:<span class="cov1" title="1">
                return time.Since(session.StartTime), nil</span>
        case StatePaused:<span class="cov1" title="1">
                if session.PausedAt != nil </span><span class="cov1" title="1">{
                        return session.PausedAt.Sub(session.StartTime), nil
                }</span>
                <span class="cov0" title="0">return time.Since(session.StartTime), nil</span>
        case StateStopped:<span class="cov0" title="0">
                return session.Duration, nil</span>
        default:<span class="cov0" title="0">
                return 0, nil</span>
        }
}

// saveSession saves a session to the database
func (t *Tracker) saveSession(session *Session) error <span class="cov9" title="26">{
        return t.db.Update(func(tx *bbolt.Tx) error </span><span class="cov9" title="26">{
                bucket := tx.Bucket(sessionsBucket)
                data, err := json.Marshal(session)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov9" title="26">return bucket.Put([]byte(session.ID), data)</span>
        })
}

// setCurrentSession sets the current active session
func (t *Tracker) setCurrentSession(session *Session) error <span class="cov7" title="15">{
        return t.db.Update(func(tx *bbolt.Tx) error </span><span class="cov7" title="15">{
                bucket := tx.Bucket(currentBucket)
                data, err := json.Marshal(session)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov7" title="15">return bucket.Put([]byte("session"), data)</span>
        })
}

// clearCurrentSession clears the current session
func (t *Tracker) clearCurrentSession() error <span class="cov6" title="11">{
        return t.db.Update(func(tx *bbolt.Tx) error </span><span class="cov6" title="11">{
                bucket := tx.Bucket(currentBucket)
                return bucket.Delete([]byte("session"))
        }</span>)
}

// GetDailyTotal returns the total time worked today
func (t *Tracker) GetDailyTotal() (time.Duration, error) <span class="cov1" title="1">{
        var total time.Duration
        today := time.Now().Truncate(24 * time.Hour)
        tomorrow := today.Add(24 * time.Hour)

        err := t.db.View(func(tx *bbolt.Tx) error </span><span class="cov1" title="1">{
                bucket := tx.Bucket(sessionsBucket)
                cursor := bucket.Cursor()

                for k, v := cursor.First(); k != nil; k, v = cursor.Next() </span><span class="cov1" title="1">{
                        var session Session
                        if err := json.Unmarshal(v, &amp;session); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Only count completed sessions from today
                        <span class="cov1" title="1">if session.State == StateStopped &amp;&amp;
                                session.StartTime.After(today) &amp;&amp;
                                session.StartTime.Before(tomorrow) </span><span class="cov1" title="1">{
                                total += session.Duration
                        }</span>
                }
                <span class="cov1" title="1">return nil</span>
        })

        <span class="cov1" title="1">return total, err</span>
}

// GetWeeklyTotal returns the total time worked this week
func (t *Tracker) GetWeeklyTotal() (time.Duration, error) <span class="cov1" title="1">{
        var total time.Duration
        now := time.Now()
        weekStart := now.AddDate(0, 0, -int(now.Weekday()))
        weekStart = weekStart.Truncate(24 * time.Hour)
        weekEnd := weekStart.Add(7 * 24 * time.Hour)

        err := t.db.View(func(tx *bbolt.Tx) error </span><span class="cov1" title="1">{
                bucket := tx.Bucket(sessionsBucket)
                cursor := bucket.Cursor()

                for k, v := cursor.First(); k != nil; k, v = cursor.Next() </span><span class="cov1" title="1">{
                        var session Session
                        if err := json.Unmarshal(v, &amp;session); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov1" title="1">if session.State == StateStopped &amp;&amp;
                                session.StartTime.After(weekStart) &amp;&amp;
                                session.StartTime.Before(weekEnd) </span><span class="cov1" title="1">{
                                total += session.Duration
                        }</span>
                }
                <span class="cov1" title="1">return nil</span>
        })

        <span class="cov1" title="1">return total, err</span>
}

// GetSessionHistory returns recent sessions
func (t *Tracker) GetSessionHistory(limit int) ([]*Session, error) <span class="cov1" title="1">{
        var sessions []*Session

        err := t.db.View(func(tx *bbolt.Tx) error </span><span class="cov1" title="1">{
                bucket := tx.Bucket(sessionsBucket)
                cursor := bucket.Cursor()

                // Collect all sessions first
                var allSessions []*Session
                for k, v := cursor.First(); k != nil; k, v = cursor.Next() </span><span class="cov3" title="3">{
                        var session Session
                        if err := json.Unmarshal(v, &amp;session); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov3" title="3">if session.State == StateStopped </span><span class="cov3" title="3">{
                                allSessions = append(allSessions, &amp;session)
                        }</span>
                }

                // Sort by start time (most recent first)
                <span class="cov1" title="1">for i := 0; i &lt; len(allSessions)-1; i++ </span><span class="cov2" title="2">{
                        for j := i + 1; j &lt; len(allSessions); j++ </span><span class="cov3" title="3">{
                                if allSessions[i].StartTime.Before(allSessions[j].StartTime) </span><span class="cov3" title="3">{
                                        allSessions[i], allSessions[j] = allSessions[j], allSessions[i]
                                }</span>
                        }
                }

                // Take only the requested number
                <span class="cov1" title="1">if limit &gt; 0 &amp;&amp; len(allSessions) &gt; limit </span><span class="cov1" title="1">{
                        sessions = allSessions[:limit]
                }</span> else<span class="cov0" title="0"> {
                        sessions = allSessions
                }</span>

                <span class="cov1" title="1">return nil</span>
        })

        <span class="cov1" title="1">return sessions, err</span>
}

// GetProjectStats returns time statistics by project
func (t *Tracker) GetProjectStats() (map[string]time.Duration, error) <span class="cov1" title="1">{
        stats := make(map[string]time.Duration)

        err := t.db.View(func(tx *bbolt.Tx) error </span><span class="cov1" title="1">{
                bucket := tx.Bucket(sessionsBucket)
                cursor := bucket.Cursor()

                for k, v := cursor.First(); k != nil; k, v = cursor.Next() </span><span class="cov3" title="3">{
                        var session Session
                        if err := json.Unmarshal(v, &amp;session); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov3" title="3">if session.State == StateStopped </span><span class="cov3" title="3">{
                                stats[session.Project] += session.Duration
                        }</span>
                }
                <span class="cov1" title="1">return nil</span>
        })

        <span class="cov1" title="1">return stats, err</span>
}

// SetIdleThreshold sets the idle detection threshold
func (t *Tracker) SetIdleThreshold(threshold time.Duration) <span class="cov0" title="0">{
        t.idleDetector = NewIdleDetector(threshold)
}</span>

// StartIdleMonitoring starts monitoring for idle state changes
func (t *Tracker) StartIdleMonitoring() error <span class="cov6" title="11">{
        if t.idleStop != nil </span><span class="cov0" title="0">{
                // Already monitoring
                return nil
        }</span>

        <span class="cov6" title="11">t.idleStop = t.idleDetector.StartIdleMonitoring(
                func() </span><span class="cov0" title="0">{
                        // On idle start - pause current session if running
                        session, err := t.GetCurrentSession()
                        if err != nil || session == nil || session.State != StateRunning </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // Auto-pause due to idle
                        <span class="cov0" title="0">_, _ = t.Pause()</span>
                },
                func() {<span class="cov0" title="0">
                        // On idle end - could potentially resume, but we'll leave that manual
                        // to avoid accidentally resuming the wrong session
                }</span>,
        )

        <span class="cov6" title="11">return nil</span>
}

// StopIdleMonitoring stops idle monitoring
func (t *Tracker) StopIdleMonitoring() <span class="cov6" title="11">{
        if t.idleStop != nil </span><span class="cov6" title="11">{
                close(t.idleStop)
                t.idleStop = nil
        }</span>
}

// IsIdle returns true if the system is currently idle
func (t *Tracker) IsIdle() (bool, error) <span class="cov0" title="0">{
        return t.idleDetector.IsIdle()
}</span>

// GetIdleTime returns the current system idle time
func (t *Tracker) GetIdleTime() (time.Duration, error) <span class="cov0" title="0">{
        return t.idleDetector.GetIdleTime()
}</span>

// generateSessionID generates a unique session ID
func generateSessionID() string <span class="cov6" title="11">{
        return fmt.Sprintf("session_%d", time.Now().UnixNano())
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
